<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>clipod Waveform Editor</title>
  <link rel="preconnect" href="https://unpkg.com" />
  <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
  <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.min.js"></script>
  <style>
    :root {
      color-scheme: dark;
    }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", sans-serif;
      color: #e5e7eb;
      background: #2d2d2d;
    }
    body > .panel {
      width: min(1100px, calc(100vw - 32px));
      margin: 16px;
    }
    h1 {
      display: none;
    }
    h1 {
      font-size: 18px;
      margin: 0 0 12px;
      font-weight: 600;
      color: #f9fafb;
    }
    .panel {
      background: #1f1f1f;
      border: 1px solid #2a2a2a;
      border-radius: 12px;
      padding: 12px 16px 72px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.35);
      position: relative;
      transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .panel.selection-active {
      border-color: #60a5fa;
      box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.2);
    }
    .panel.punch-active {
      border-color: #f87171;
      box-shadow: 0 0 0 2px rgba(248, 113, 113, 0.25);
    }
    .top-row {
      position: absolute;
      left: 16px;
      right: 16px;
      bottom: 12px;
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      font-size: 12px;
      color: #9ca3af;
      background: #1f1d1b;
      border: 1px solid #2d2a27;
      border-radius: 12px;
      padding: 8px 10px;
      opacity: 0;
      pointer-events: none;
      transform: translateY(6px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .panel.show-controls .top-row,
    .top-row:hover,
    .top-row:focus-within {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }
    .transport-controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .top-row button {
      border: 1px solid #2d2a27;
      background: #262321;
      color: #d9d6d2;
      font-size: 13px;
      padding: 6px 12px;
      border-radius: 10px;
      letter-spacing: 0.04em;
    }
    .recording-panel {
      margin: 20px 0;
      padding: 28px 32px;
      border-radius: 14px;
      border: 1px solid #2f2925;
      background: #1f1c1a;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      display: none;
    }
    .recording-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease;
      pointer-events: none;
      z-index: 6;
    }
    .recording-modal .recording-overlay {
      opacity: 1;
      visibility: visible;
    }
    .empty-record-cta {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 4;
    }
    .empty-record-cta button {
      pointer-events: auto;
    }
    .empty-record-btn {
      border: 1px solid #475569;
      background: #1f2937;
      color: #f9fafb;
      font-size: 20px;
      font-weight: 600;
      padding: 16px 36px;
      border-radius: 999px;
      box-shadow: 0 0 18px rgba(96, 165, 250, 0.25);
    }
    .empty-record-btn:hover {
      border-color: #60a5fa;
    }
    .has-voice .empty-record-cta,
    .recording-modal .empty-record-cta {
      display: none;
    }
    .recording-actions {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
    }
    .recording-button {
      border: 1px solid #3a3230;
      background: #2a2624;
      color: #f5f5f5;
      font-size: 18px;
      font-weight: 500;
      padding: 12px 26px;
      border-radius: 999px;
      min-width: 180px;
      transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .recording-stop {
      border: 1px solid #4b1e1e;
      background: #3b1b1b;
      color: #fca5a5;
      font-size: 14px;
      font-weight: 600;
      padding: 8px 16px;
      border-radius: 999px;
    }
    .recording-stop:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .recording-button.recording {
      background: #6e7b7c;
      border-color: #97a9ab;
      animation: recordPulse 2.4s ease-in-out infinite;
    }
    .recording-timer {
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      font-variant-numeric: tabular-nums;
      color: #b6c4c0;
    }
    .punch-button {
      border: 1px solid #334155;
      background: #0f172a;
      color: #e5e7eb;
      font-size: 14px;
      font-weight: 600;
      padding: 8px 14px;
      border-radius: 999px;
    }
    .punch-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .punch-info {
      font-size: 12px;
      color: #fecaca;
      border: 1px solid #7f1d1d;
      background: rgba(248, 113, 113, 0.15);
      padding: 4px 10px;
      border-radius: 999px;
      letter-spacing: 0.04em;
    }
    #recordingCanvas {
      width: 100%;
      max-width: 780px;
      height: 120px;
      border-radius: 12px;
      border: 1px solid #2f2a26;
      background: #1e1c1a;
      box-shadow: inset 0 0 24px rgba(0, 0, 0, 0.35);
    }
    @keyframes recordPulse {
      0% {
        box-shadow: 0 0 0 0 rgba(151, 169, 171, 0.3);
      }
      70% {
        box-shadow: 0 0 0 12px rgba(151, 169, 171, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(151, 169, 171, 0);
      }
    }
    .file-menu {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .file-menu-meta {
      display: none;
    }
    .file-menu-meta .file-label,
    .file-menu-meta .bgm-file-label {
      max-width: 220px;
    }
    .icon-button {
      display: none;
    }
    #fileInput,
    #bgmInput,
    #sfxInput {
      display: none;
    }
    .file-label {
      font-size: 12px;
      color: #d1d5db;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 40%;
    }
    #waveform {
      min-width: 100%;
    }
    #waveformWrap {
      margin-top: 0;
      overflow-x: auto;
      overflow-y: hidden;
      border: 1px solid #2d2a27;
      border-radius: 10px;
      background: #1f1d1b;
      padding: 4px 0;
      position: relative;
    }
    .zoom-controls {
      position: absolute;
      top: 6px;
      right: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
      background: rgba(31, 29, 27, 0.9);
      border: 1px solid #2d2a27;
      border-radius: 999px;
      padding: 4px 8px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 6;
    }
    #waveformWrap.show-zoom .zoom-controls {
      opacity: 1;
      pointer-events: auto;
    }
    .voice-header {
      display: none;
    }
    .track-label {
      font-weight: 600;
      color: #f9fafb;
      letter-spacing: 0.04em;
    }
    .zoom-indicator strong {
      color: #f9fafb;
      font-weight: 600;
    }
    .status-line {
      display: none;
      flex-wrap: wrap;
      gap: 8px 12px;
    }
    .panel.show-status .status-line {
      display: flex;
    }
    .bgm-panel {
      margin: 0 0 4px;
    }
    .bgm-panel.bgm-loaded {
      margin-top: 0;
    }
    .bgm-header {
      display: none;
    }
    .bgm-track-label {
      font-weight: 600;
      color: #f9fafb;
    }
    .bgm-file-label {
      font-weight: 600;
      color: #bbf7d0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 240px;
    }
    #bgmTimelineWrap {
      margin-top: 0;
      overflow-x: auto;
      overflow-y: hidden;
      border: 1px solid #2d2a27;
      border-radius: 10px;
      background: #1f1d1b;
      padding: 4px 0;
      position: relative;
    }
    #bgmTimelineWrap.bgm-empty {
      border-style: dashed;
    }
    #bgmTimeline {
      position: relative;
      height: 104px;
      min-width: 100%;
    }
    .bgm-placeholder {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      color: #8fb7b3;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      pointer-events: none;
      opacity: 0.7;
    }
    #bgmMarkers {
      display: none;
    }
    #bgmWaveform {
      position: absolute;
      top: 32px;
      left: 0;
      right: 0;
      height: 64px;
      pointer-events: none;
      opacity: 0.75;
      z-index: 1;
    }
    .bgm-marker {
      position: absolute;
      top: 0;
      transform: translateX(-50%);
      white-space: nowrap;
    }
    #sfxLane {
      position: absolute;
      top: 8px;
      left: 0;
      right: 0;
      height: 16px;
      z-index: 4;
    }
    #bgmLane {
      position: absolute;
      top: 32px;
      left: 0;
      right: 0;
      height: 64px;
      z-index: 3;
    }
    .bgm-segment {
      position: absolute;
      top: 10px;
      height: 44px;
      border-radius: 8px;
      background: rgba(16, 185, 129, 0.25);
      border: 1px solid #10b981;
      cursor: grab;
      display: flex;
      align-items: center;
      padding: 0 8px;
      font-size: 11px;
      color: #ecfdf5;
      box-sizing: border-box;
      user-select: none;
      overflow: hidden;
      z-index: 4;
    }
    .bgm-segment::before,
    .bgm-segment::after {
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 0;
    }
    .bgm-segment::before {
      left: 0;
      width: var(--fade-in-pct, 0%);
      background: linear-gradient(90deg, rgba(12, 74, 52, 0.7), rgba(12, 74, 52, 0));
    }
    .bgm-segment::after {
      right: 0;
      width: var(--fade-out-pct, 0%);
      background: linear-gradient(270deg, rgba(12, 74, 52, 0.7), rgba(12, 74, 52, 0));
    }
    .segment-label {
      position: relative;
      z-index: 2;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .sfx-segment {
      position: absolute;
      top: 3px;
      height: 10px;
      border-radius: 6px;
      background: rgba(74, 144, 217, 0.35);
      border: 1px solid #4a90d9;
      cursor: grab;
      display: flex;
      align-items: center;
      padding: 0 6px;
      font-size: 10px;
      color: #e6f2ff;
      box-sizing: border-box;
      user-select: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      z-index: 5;
    }
    .bgm-segment.selected {
      background: rgba(16, 185, 129, 0.45);
      border: 2px solid rgba(59, 130, 246, 0.8);
      border-color: rgba(59, 130, 246, 0.8);
      box-shadow: 0 0 12px 3px rgba(59, 130, 246, 0.7);
      transition: box-shadow 0.15s ease, border-color 0.15s ease;
    }
    .sfx-segment.selected {
      background: rgba(74, 144, 217, 0.55);
      border: 2px solid rgba(59, 130, 246, 0.8);
      border-color: rgba(59, 130, 246, 0.8);
      box-shadow: 0 0 12px 3px rgba(59, 130, 246, 0.7);
      transition: box-shadow 0.15s ease, border-color 0.15s ease;
    }
    .fade-indicator {
      position: absolute;
      top: 4px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 1px 4px;
      border-radius: 6px;
      font-size: 10px;
      color: #ecfdf5;
      background: rgba(15, 23, 42, 0.65);
      border: 1px solid rgba(148, 163, 184, 0.45);
      cursor: pointer;
      z-index: 3;
      transition: opacity 0.15s ease;
    }
    .fade-indicator.fade-in {
      left: 6px;
    }
    .fade-indicator.fade-out {
      right: 6px;
    }
    .fade-indicator.is-empty {
      opacity: 0;
    }
    .bgm-segment:hover .fade-indicator.is-empty,
    .fade-indicator.editing {
      opacity: 1;
    }
    .fade-indicator input {
      display: none;
      width: 42px;
      padding: 1px 2px;
      font-size: 10px;
      border-radius: 4px;
      border: 1px solid #334155;
      background: #0f172a;
      color: #e2e8f0;
    }
    .fade-indicator.editing input {
      display: inline-block;
    }
    .fade-indicator.editing .fade-label {
      display: none;
    }
    .bgm-segment.pasted,
    .sfx-segment.pasted {
      animation: pastedPulse 0.6s ease;
    }
    .bgm-segment.selected,
    .sfx-segment.selected {
      box-shadow: 0 0 8px 2px rgba(59, 130, 246, 0.6);
      transition: box-shadow 0.15s ease;
    }
    @keyframes pastedPulse {
      0% {
        box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.7);
      }
      100% {
        box-shadow: 0 0 0 10px rgba(56, 189, 248, 0);
      }
    }
    .bgm-segment .handle,
    .sfx-segment .handle {
      position: absolute;
      top: 0;
      width: 8px;
      height: 100%;
      cursor: ew-resize;
    }
    .bgm-segment .handle.left {
      left: 0;
    }
    .bgm-segment .handle.right {
      right: 0;
    }
    .bgm-info {
      display: none;
    }
    .bgm-info input[type="number"] {
      width: 72px;
      padding: 2px 4px;
      font-size: 12px;
    }
    .bgm-info input[type="range"] {
      width: 140px;
    }
    .bgm-info label {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .bgm-info label span {
      min-width: 54px;
    }
    .bgm-drop {
      margin-top: 6px;
      font-size: 11px;
      color: #6b7280;
    }
    .selection-indicator {
      padding: 2px 6px;
      border-radius: 999px;
      background: #1f2937;
      color: #9ca3af;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .panel.selection-active .selection-indicator {
      background: #60a5fa;
      color: #0b0f14;
    }
    #status {
      display: none;
      max-width: 100%;
      word-break: break-word;
    }
    .panel.show-status #status {
      display: block;
    }
    #status.error {
      color: #fca5a5;
    }
    button {
      border: 1px solid #334155;
      background: #0f172a;
      color: #e5e7eb;
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 8px;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button:not(:disabled):hover {
      border-color: #60a5fa;
      color: #f9fafb;
    }
    .track-playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #fbbf24;
      pointer-events: none;
      z-index: 5;
      opacity: 0.8;
    }
    .bgm-drop {
      display: none;
    }
    .shortcuts-panel {
      position: absolute;
      right: 16px;
      bottom: 16px;
      background: #0f172a;
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 12px 14px;
      font-size: 12px;
      color: #9ca3af;
      max-width: 280px;
      display: none;
      z-index: 7;
    }
    .panel.show-shortcuts .shortcuts-panel {
      display: block;
    }
    .shortcuts-panel h2 {
      font-size: 12px;
      margin: 0 0 6px;
      color: #f9fafb;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .shortcuts-panel ul {
      margin: 0;
      padding-left: 16px;
    }
    .shortcuts-panel li {
      margin-bottom: 4px;
    }
    .recording-modal .recording-panel {
      display: flex;
      position: fixed;
      left: var(--recording-modal-left, 50%);
      top: var(--recording-modal-top, 50%);
      transform: translate(var(--recording-modal-translate-x, -50%), var(--recording-modal-translate-y, -50%));
      margin: 0;
      padding: 10px 12px;
      width: min(var(--recording-modal-width, 300px), calc(100% - 32px));
      height: var(--recording-modal-height, 200px);
      gap: 8px;
      background: rgba(31, 28, 26, 0.92);
      border-color: #2f2925;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
      box-sizing: border-box;
      z-index: 8;
    }
    .recording-modal .recording-actions {
      width: 100%;
      justify-content: space-between;
      flex-wrap: nowrap;
    }
    .recording-modal .recording-button {
      min-width: 90px;
      font-size: 13px;
      padding: 6px 12px;
    }
    .recording-modal .recording-timer {
      font-size: 11px;
      letter-spacing: 0.12em;
    }
    .recording-modal #recordingCanvas {
      height: 90px;
    }
    .top-row {
      padding-bottom: 4px;
    }
    .recording-active .recording-panel {
      margin-top: 0;
    }
    .panel.minimal .status-line,
    .panel.minimal #status {
      display: none;
    }
    .panel.minimal.show-status .status-line,
    .panel.minimal.show-status #status {
      display: flex;
    }
  </style>
</head>
  <body>
  <div class="panel" id="editor">
    <div class="recording-overlay" id="recordingOverlay" aria-hidden="true"></div>
    <div class="empty-record-cta" id="emptyRecordCta">
      <button type="button" class="empty-record-btn" id="emptyRecordBtn">録音を開始</button>
    </div>
    <div class="top-row">
      <div class="transport-controls">
        <button type="button" id="playBtn">再生</button>
        <button type="button" id="stopBtn">停止</button>
      </div>
      <div class="file-menu" id="fileMenu">
        <button type="button" id="filePickerBtn">VOICEを読み込む</button>
        <button type="button" id="bgmPickerBtn">BGMを読み込む</button>
        <button type="button" id="addBgm">効果音を追加</button>
          <button type="button" id="mixBgm" disabled>書き出し</button>
        <div class="file-menu-meta">
          <span class="file-label" id="fileLabel">未読込</span>
          <span class="bgm-file-label" id="bgmFileLabel">BGM未読込</span>
        </div>
      </div>
      <input type="file" id="fileInput" accept="audio/*" />
      <input type="file" id="bgmInput" accept="audio/*" />
      <input type="file" id="sfxInput" accept="audio/*" />
    </div>
    <div class="recording-panel" id="recordingPanel">
      <div class="recording-actions">
        <button type="button" class="recording-button" id="recordBtn">録音</button>
        <button type="button" class="recording-stop" id="recordStopBtn">停止</button>
      </div>
      <div class="recording-timer" id="recordTimer">00:00</div>
      <div class="punch-info" id="punchInfo" hidden>差し替え録音中…</div>
      <canvas id="recordingCanvas" width="720" height="120"></canvas>
    </div>
      <div class="voice-header">
        <span class="track-label">VOICE</span>
      </div>
    <div id="waveformWrap">
      <div id="waveform"></div>
      <span class="track-playhead" id="voicePlayhead"></span>
      <div class="zoom-controls" id="zoomControls">
        <span class="zoom-indicator">縮尺 <strong id="zoomLevel">--</strong></span>
        <button type="button" id="resetZoom" disabled>戻す</button>
      </div>
    </div>
    <div class="status-line">
      <span>再生 <strong id="currentTime">00:00.00</strong></span>
      <span>範囲 <strong id="selectionStart">--:--.--</strong>–<strong id="selectionEnd">--:--.--</strong></span>
      <span>全体 <strong id="duration">--:--.--</strong></span>
      <span class="selection-indicator" id="selectionIndicator">未選択</span>
    </div>
    <div id="status">準備完了</div>
    <div class="bgm-panel">
      <div class="bgm-header">
        <span class="bgm-track-label">BGM</span>
      </div>
      <div id="bgmTimelineWrap">
        <div id="bgmTimeline">
          <div class="bgm-placeholder" id="bgmPlaceholder">BGMを追加</div>
          <div id="bgmMarkers"></div>
          <div id="bgmWaveform"></div>
          <span class="track-playhead" id="bgmPlayhead"></span>
          <div id="sfxLane"></div>
          <div id="bgmLane"></div>
        </div>
      </div>
      <div class="bgm-info">
        <span>開始 <strong id="bgmStart">--:--.--</strong></span>
        <span>終了 <strong id="bgmEnd">--:--.--</strong></span>
        <label><span>音量</span><input type="range" id="bgmVolume" min="0" max="1" step="0.05" value="0.25" disabled></label>
        <label><span>フェードイン</span><input type="number" id="bgmFadeIn" min="0" max="10" step="0.1" value="0" disabled></label>
        <label><span>フェードアウト</span><input type="number" id="bgmFadeOut" min="0" max="10" step="0.1" value="0" disabled></label>
      </div>
    </div>
    <div class="shortcuts-panel" id="shortcutsPanel">
      <h2>ショートカット</h2>
      <ul>
        <li><strong>Space</strong>: 再生/停止</li>
        <li><strong>Shift+I</strong>/<strong>Shift+O</strong>: 範囲開始/終了</li>
        <li><strong>D</strong>: 範囲削除</li>
        <li><strong>⌘+Z</strong>: 削除を戻す</li>
        <li><strong>⌘+⇧+Z</strong>: やり直し(未対応)</li>
        <li><strong>←</strong>/<strong>→</strong>: 再生位置を微調整</li>
        <li><strong>⌘+←</strong>/<strong>⌘+→</strong>: 先頭/末尾へ移動</li>
        <li><strong>E</strong>: 書き出し</li>
        <li><strong>Esc</strong>: 選択解除</li>
        <li><strong>?</strong>: ショートカット表示</li>
      </ul>
    </div>
  </div>

  <script>
    const fileInput = document.getElementById("fileInput");
    const fileLabel = document.getElementById("fileLabel");
    const playBtn = document.getElementById("playBtn");
    const stopBtn = document.getElementById("stopBtn");
    const filePickerBtn = document.getElementById("filePickerBtn");
    const bgmPickerBtn = document.getElementById("bgmPickerBtn");
    const recordBtn = document.getElementById("recordBtn");
    const recordStopBtn = document.getElementById("recordStopBtn");
    const emptyRecordBtn = document.getElementById("emptyRecordBtn");
    const recordingOverlay = document.getElementById("recordingOverlay");
    const recordTimer = document.getElementById("recordTimer");
    const recordingCanvas = document.getElementById("recordingCanvas");
    const recordingPanel = document.getElementById("recordingPanel");
    const punchBtn = document.getElementById("punchBtn");
    const punchInfo = document.getElementById("punchInfo");
    const statusEl = document.getElementById("status");
    const currentTimeEl = document.getElementById("currentTime");
    const durationEl = document.getElementById("duration");
    const selectionStartEl = document.getElementById("selectionStart");
    const selectionEndEl = document.getElementById("selectionEnd");
    const selectionIndicatorEl = document.getElementById("selectionIndicator");
    const editorEl = document.getElementById("editor");
      const zoomLevelEl = document.getElementById("zoomLevel");
      const resetZoomBtn = document.getElementById("resetZoom");
    const waveformWrap = document.getElementById("waveformWrap");
    const waveformEl = document.getElementById("waveform");
    const bgmTimelineWrap = document.getElementById("bgmTimelineWrap");
    const bgmTimeline = document.getElementById("bgmTimeline");
    const bgmLane = document.getElementById("bgmLane");
    const sfxLane = document.getElementById("sfxLane");
    const bgmMarkers = document.getElementById("bgmMarkers");
    const bgmWaveformEl = document.getElementById("bgmWaveform");
    const bgmInput = document.getElementById("bgmInput");
    const sfxInput = document.getElementById("sfxInput");
    const bgmPlaceholder = document.getElementById("bgmPlaceholder");
    const addBgmBtn = document.getElementById("addBgm");
    const mixBgmBtn = document.getElementById("mixBgm");
    const bgmFileLabel = document.getElementById("bgmFileLabel");
    const bgmPanel = document.querySelector(".bgm-panel");
    const voicePlayhead = document.getElementById("voicePlayhead");
    const bgmPlayhead = document.getElementById("bgmPlayhead");
    const bgmStartEl = document.getElementById("bgmStart");
    const bgmEndEl = document.getElementById("bgmEnd");
    const bgmVolumeEl = document.getElementById("bgmVolume");
    const bgmFadeInEl = document.getElementById("bgmFadeIn");
    const bgmFadeOutEl = document.getElementById("bgmFadeOut");

    let wavesurfer = null;
    let regions = null;
    let activeRegion = null;
    let selection = { start: null, end: null };
    let activeObjectUrl = null;
    let autoMode = false;
    let hasVoiceAudio = false;
    let pendingSeekTime = null;
    let pendingPlay = false;
    let busy = false;
    let zoomBase = 1;
    let zoomLevel = 1;
    let timelinePxPerSec = 1;
    let bgmSegments = [];
    let sfxSegments = [];
    let selectedBgmId = null;
    let selectedBlock = null;
    let bgmIdCounter = 1;
    let dragState = null;
    let syncingScroll = false;
    let bgmFile = null;
    let bgmUploadPath = null;
    let bgmDuration = 0;
    let bgmObjectUrl = null;
    let bgmWaveSurfer = null;
    let previewContext = null;
    let previewStartOffset = 0;
    let previewBgmBuffer = null;
    let previewSfxBuffers = new Map();
    let previewSources = [];
    let previewGain = null;
    let clipboardSegment = null;
    let copyTime = 0;
    let isMetaDown = false;
    const bgmDefaultVolume = 0.25;
    const bgmDefaultFade = 0;
    let mediaRecorder = null;
    let recordingStream = null;
    let recordingChunks = [];
    let recordingActive = false;
    let recordingStartTime = 0;
    let recordingTimerId = null;
    let recordingAnimationId = null;
    let recordingLastFrame = 0;
    let recordingLastTimerSecond = null;
    let recordingAudioContext = null;
    let recordingAnalyser = null;
    let recordingSource = null;
    let recordingMode = "new";
    let recordingFocusTime = 0;
    let recordingMimeType = "";
    const LONG_RECORDING_SECONDS = 20 * 60;
    let punchSelection = null;
    let recordingDirty = false;
    let showControlsTimeout = null;
    let statusAutoHideTimeout = null;
    let statusAutoVisible = false;

    const formatSeconds = (value) => {
      if (value === null || Number.isNaN(value)) {
        return "--:--.--";
      }
      const minutes = Math.floor(value / 60);
      const seconds = Math.floor(value % 60);
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
    };

    const formatTime = (value) => {
      if (value === null || Number.isNaN(value)) {
        return "--:--.--";
      }
      const minutes = Math.floor(value / 60);
      const seconds = Math.floor(value % 60);
      const ms = Math.floor((value - Math.floor(value)) * 100);
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}.${String(ms).padStart(2, "0")}`;
    };

    const pickRecordingMimeType = () => {
      if (typeof MediaRecorder === "undefined" || !MediaRecorder.isTypeSupported) {
        return "";
      }
      const candidates = [
        "audio/webm;codecs=opus",
        "audio/webm",
        "audio/ogg;codecs=opus",
        "audio/ogg",
      ];
      return candidates.find((type) => MediaRecorder.isTypeSupported(type)) || "";
    };

    const mimeTypeToExtension = (mimeType) => {
      if (!mimeType) return null;
      if (mimeType.includes("webm")) return "webm";
      if (mimeType.includes("ogg")) return "ogg";
      if (mimeType.includes("wav")) return "wav";
      return null;
    };

    recordingMimeType = pickRecordingMimeType();

    const updateStatus = (text, isError = false) => {
      statusEl.textContent = text;
      statusEl.classList.toggle("error", isError);
      const shouldShow = isError || text.includes("?file=") || text.includes("書き出し完了") || text.includes("録音中");
      if (!shouldShow) return;
      if (!editorEl.classList.contains("show-status")) {
        editorEl.classList.add("show-status");
        statusAutoVisible = true;
      }
      if (statusAutoHideTimeout) {
        clearTimeout(statusAutoHideTimeout);
      }
      statusAutoHideTimeout = setTimeout(() => {
        if (statusAutoVisible) {
          editorEl.classList.remove("show-status");
        }
        statusAutoVisible = false;
        if (!editorEl.classList.contains("show-status") && !statusEl.classList.contains("error")) {
          statusEl.textContent = "準備完了";
        }
      }, 4000);
    };

    const updateSelectionUI = () => {
      if (selectionStartEl) {
        selectionStartEl.textContent = selection.start === null ? "--:--.--" : formatTime(selection.start);
      }
      if (selectionEndEl) {
        selectionEndEl.textContent = selection.end === null ? "--:--.--" : formatTime(selection.end);
      }
      const hasSelection = selection.start !== null && selection.end !== null;
      if (editorEl) {
        editorEl.classList.toggle("selection-active", hasSelection);
      }
      if (selectionIndicatorEl) {
        selectionIndicatorEl.textContent = hasSelection ? "選択中" : "未選択";
      }
      if (punchBtn) {
        punchBtn.hidden = !hasSelection;
      }
    };

    const getSelectedSegment = () => (
      bgmSegments.find((item) => item.id === selectedBgmId)
      || sfxSegments.find((item) => item.id === selectedBgmId)
      || null
    );

    const addPasteHighlight = (segment) => {
      if (!segment?.element) return;
      segment.element.classList.add("pasted");
      setTimeout(() => segment.element?.classList.remove("pasted"), 600);
    };

    const addCopyHighlight = (segment) => {
      if (!segment?.element) return;
      segment.element.classList.add("pasted");
      setTimeout(() => segment.element?.classList.remove("pasted"), 300);
    };

    const pasteSegmentAt = (segment, time) => {
      if (!segment) return;
      const duration = Math.max(0.05, segment.duration || 0.05);
      const start = Math.max(0, time);
      const end = start + duration;
      const clone = {
        id: bgmIdCounter++,
        file: segment.file,
        name: segment.name,
        start,
        end,
        offset: segment.offset || 0,
        duration: segment.duration || duration,
        volume: segment.volume,
        fadeIn: segment.fadeIn,
        fadeOut: segment.fadeOut,
        track: segment.type || "bgm",
      };
      if (clone.track === "sfx") {
        sfxSegments.push(clone);
      } else {
        bgmSegments.push(clone);
      }
      renderBgmSegments();
      selectBgm(clone.id);
      addPasteHighlight(clone);
    };

      const updateEmptyState = () => {
        if (editorEl) {
          editorEl.classList.toggle("has-voice", hasVoiceAudio);
        }
      };

      const updateZoomUI = () => {
        if (zoomLevelEl) {
          zoomLevelEl.textContent = `${Math.round(zoomLevel)}`;
        }
        if (resetZoomBtn) {
          resetZoomBtn.disabled = zoomLevel === zoomBase;
        }
      };

    const applyZoom = (value) => {
      if (!wavesurfer) return;
      zoomLevel = Math.max(1, value);
      wavesurfer.zoom(zoomLevel);
      if (bgmWaveSurfer) {
        bgmWaveSurfer.zoom(zoomLevel);
      }
      updateZoomUI();
      updateTimelineScale();
    };

    const resetZoom = () => {
      applyZoom(zoomBase);
      waveformWrap.scrollLeft = 0;
      bgmTimelineWrap.scrollLeft = 0;
    };

    const updatePlayControls = () => {
      const isPlaying = wavesurfer ? wavesurfer.isPlaying() : false;
      if (playBtn) {
        playBtn.textContent = isPlaying ? "一時停止" : "再生";
      }
      if (stopBtn) {
        stopBtn.disabled = !wavesurfer;
      }
    };

    const updateRecordingUI = () => {
      document.body.classList.toggle("recording-active", recordingActive);
      document.body.classList.toggle("recording-modal", recordingActive);
      if (recordBtn) {
        recordBtn.classList.toggle("recording", recordingActive);
        recordBtn.textContent = recordingActive ? "録音中" : "録音";
        recordBtn.disabled = recordingActive;
      }
      if (recordStopBtn) {
        recordStopBtn.disabled = !recordingActive;
      }
      if (punchInfo) {
        punchInfo.hidden = !(recordingActive && recordingMode === "punch");
      }
      if (editorEl) {
        editorEl.classList.toggle("punch-active", recordingActive && recordingMode === "punch");
        editorEl.classList.toggle("minimal", !recordingActive);
      }
      if (!recordingActive) {
        if (recordTimer) {
          recordTimer.textContent = "00:00";
        }
        resizeRecordingCanvas();
      } else {
        updateStatus("録音中…");
        if (editorEl && editorEl.classList.contains("show-status")) {
          editorEl.classList.remove("show-status");
        }
        positionRecordingOverlay();
      }
      updateEmptyState();
    };

    const formatTimer = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
    };

    const updateRecordingTimer = () => {
      if (!recordingActive) return;
      const elapsed = Math.max(0, (Date.now() - recordingStartTime) / 1000);
      const rounded = Math.floor(elapsed);
      if (rounded !== recordingLastTimerSecond) {
        recordTimer.textContent = formatTimer(elapsed);
        recordingLastTimerSecond = rounded;
      }
      recordingTimerId = requestAnimationFrame(updateRecordingTimer);
    };

    const resizeRecordingCanvas = () => {
      if (!recordingCanvas) return { width: 0, height: 0 };
      const ratio = window.devicePixelRatio || 1;
      const width = Math.max(1, Math.floor(recordingCanvas.clientWidth * ratio));
      const height = Math.max(1, Math.floor(recordingCanvas.clientHeight * ratio));
      if (recordingCanvas.width !== width) {
        recordingCanvas.width = width;
      }
      if (recordingCanvas.height !== height) {
        recordingCanvas.height = height;
      }
      return { width, height };
    };

    const drawRecordingWaveform = () => {
      if (!recordingActive || !recordingAnalyser || !recordingCanvas) return;
      const now = performance.now();
      if (now - recordingLastFrame < 120) {
        recordingAnimationId = requestAnimationFrame(drawRecordingWaveform);
        return;
      }
      recordingLastFrame = now;
      const canvas = recordingCanvas;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const { width, height } = resizeRecordingCanvas();
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
      const bufferLength = recordingAnalyser.fftSize;
      const dataArray = new Uint8Array(bufferLength);
      recordingAnalyser.getByteTimeDomainData(dataArray);
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = "#1e1c1a";
      ctx.fillRect(0, 0, width, height);
      ctx.lineWidth = 1.8;
      ctx.strokeStyle = "#7fa8a6";
      ctx.shadowColor = "rgba(127, 168, 166, 0.16)";
      ctx.shadowBlur = 6;
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      const sliceWidth = width / bufferLength;
      let x = 0;
      const smoothingWindow = 20;
      for (let i = 0; i < bufferLength; i += 1) {
        let sum = 0;
        let count = 0;
        for (let j = 0; j < smoothingWindow; j += 1) {
          const idx = Math.min(bufferLength - 1, i + j);
          sum += dataArray[idx];
          count += 1;
        }
        const centered = (sum / count - 128) / 128.0;
        const eased = Math.tanh(centered * 1.9);
        const y = (height / 2) + eased * (height * 0.42);
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
        x += sliceWidth;
      }
      ctx.lineTo(width, height / 2);
      ctx.stroke();
      recordingAnimationId = requestAnimationFrame(drawRecordingWaveform);
    };

    const stopRecordingAnimation = () => {
      if (recordingAnimationId) {
        cancelAnimationFrame(recordingAnimationId);
        recordingAnimationId = null;
      }
      if (recordingTimerId) {
        cancelAnimationFrame(recordingTimerId);
        recordingTimerId = null;
      }
    };

    const stopRecordingStream = async () => {
      if (recordingSource) {
        recordingSource.disconnect();
        recordingSource = null;
      }
      if (recordingAnalyser) {
        recordingAnalyser.disconnect();
        recordingAnalyser = null;
      }
      if (recordingAudioContext) {
        await recordingAudioContext.close();
        recordingAudioContext = null;
      }
      if (recordingStream) {
        recordingStream.getTracks().forEach((track) => track.stop());
        recordingStream = null;
      }
    };

    const encodeWav = (audioBuffer) => {
      const numChannels = audioBuffer.numberOfChannels;
      const sampleRate = audioBuffer.sampleRate;
      const length = audioBuffer.length * numChannels * 2 + 44;
      const buffer = new ArrayBuffer(length);
      const view = new DataView(buffer);
      const writeString = (offset, value) => {
        for (let i = 0; i < value.length; i += 1) {
          view.setUint8(offset + i, value.charCodeAt(i));
        }
      };
      const channels = [];
      for (let i = 0; i < numChannels; i += 1) {
        channels.push(audioBuffer.getChannelData(i));
      }
      let offset = 0;
      writeString(offset, "RIFF");
      offset += 4;
      view.setUint32(offset, length - 8, true);
      offset += 4;
      writeString(offset, "WAVE");
      offset += 4;
      writeString(offset, "fmt ");
      offset += 4;
      view.setUint32(offset, 16, true);
      offset += 4;
      view.setUint16(offset, 1, true);
      offset += 2;
      view.setUint16(offset, numChannels, true);
      offset += 2;
      view.setUint32(offset, sampleRate, true);
      offset += 4;
      view.setUint32(offset, sampleRate * numChannels * 2, true);
      offset += 4;
      view.setUint16(offset, numChannels * 2, true);
      offset += 2;
      view.setUint16(offset, 16, true);
      offset += 2;
      writeString(offset, "data");
      offset += 4;
      view.setUint32(offset, length - offset - 4, true);
      offset += 4;
      let interleavedIndex = 0;
      const interleavedLength = audioBuffer.length * numChannels;
      while (interleavedIndex < interleavedLength) {
        for (let channel = 0; channel < numChannels; channel += 1) {
          const sample = Math.max(-1, Math.min(1, channels[channel][interleavedIndex / numChannels]));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true);
          offset += 2;
        }
        interleavedIndex += numChannels;
      }
      return new Blob([buffer], { type: "audio/wav" });
    };

    const getAutoRecordingFileName = (extension = "wav") => `auto-${Date.now()}.${extension}`;

    const uploadRecording = async (blob, filename, shouldReload = true) => {
      const resolvedName = filename || getAutoRecordingFileName("wav");
      const formData = new FormData();
      formData.append("file", blob, resolvedName);
      console.log("recording upload", { size: blob.size, type: blob.type, filename: resolvedName });
      updateStatus("保存中…");
      const res = await fetch("/api/upload", { method: "POST", body: formData });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || `Upload failed (${res.status})`);
      }
      const payload = await res.json();
        console.log("recording upload ok", payload);
        updateStatus("保存しました。");
      if (!shouldReload) return payload;
      const nextPath = payload?.path ? `/api/auto?file=${encodeURIComponent(payload.path)}` : "/api/auto";
      await reloadAutoForced(0, false, nextPath, true);
      return payload;
    };

    const punchInRecording = async (blob, start, end, seekTime = null) => {
      const formData = new FormData();
      formData.append("file", blob, "punch.wav");
      formData.append("start", String(start));
      formData.append("end", String(end));
      console.log("punch upload", { size: blob.size, start, end });
      updateStatus("挿入中…");
      const res = await fetch("/api/punch", { method: "POST", body: formData });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || `Punch-in failed (${res.status})`);
      }
        console.log("punch upload ok");
      updateStatus("挿入完了。");
      await reloadAutoForced(seekTime ?? start, false, "/api/auto", true);
    };

    const updateRecordingControls = () => {
      const supported = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
      if (recordBtn) {
        recordBtn.disabled = !supported;
      }
      if (recordStopBtn) {
        recordStopBtn.disabled = !recordingActive;
      }
      if (!supported) {
        if (recordBtn) {
          recordBtn.textContent = "録音不可";
        }
      } else if (!recordingActive) {
        if (recordBtn) {
          recordBtn.textContent = "録音";
        }
      }
      if (punchBtn && recordBtn) {
        punchBtn.disabled = recordBtn.disabled;
      }
    };

    const updateBgmPlaceholder = () => {
      const hasBgm = !!bgmFile || bgmSegments.length > 0 || sfxSegments.length > 0;
      if (bgmPlaceholder) {
        bgmPlaceholder.hidden = hasBgm;
      }
      if (bgmTimelineWrap) {
        bgmTimelineWrap.classList.toggle("bgm-empty", !hasBgm);
      }
    };

    const getTimelineDuration = () => {
      const voiceDuration = wavesurfer ? wavesurfer.getDuration() || 0 : 0;
      const maxSegmentEnd = bgmSegments.reduce((max, segment) => Math.max(max, segment.end), 0);
      const maxSfxEnd = sfxSegments.reduce((max, segment) => Math.max(max, segment.end), 0);
      return Math.max(voiceDuration, bgmDuration, maxSegmentEnd, maxSfxEnd);
    };

    const refreshTimelineWidth = () => {
      const duration = wavesurfer ? wavesurfer.getDuration() || 0 : 0;
      if (!duration) return;
      const timelineDuration = getTimelineDuration();
      const voiceWidth = Math.max(waveformWrap.clientWidth, duration * timelinePxPerSec);
      const timelineWidth = Math.max(bgmTimelineWrap.clientWidth, timelineDuration * timelinePxPerSec);
      bgmTimeline.style.width = `${timelineWidth}px`;
      if (waveformEl) {
        waveformEl.style.width = `${voiceWidth}px`;
      }
    };

    const updateTimelineScale = () => {
      const duration = wavesurfer ? wavesurfer.getDuration() || 0 : 0;
      if (!duration) return;
      const baseWidth = Math.max(waveformWrap.clientWidth, duration * zoomLevel);
      timelinePxPerSec = baseWidth / duration;
      renderMarkers(getTimelineDuration());
      renderBgmSegments(false);
      updateBgmWaveformWidth();
      updatePlayheadUI(getPlaybackTime());
    };

    const renderMarkers = (duration) => {
      bgmMarkers.innerHTML = "";
      if (!duration) return;
      const step = duration <= 60 ? 10 : duration <= 300 ? 30 : 60;
      for (let t = 0; t <= duration; t += step) {
        const marker = document.createElement("div");
        marker.className = "bgm-marker";
        marker.style.left = `${t * timelinePxPerSec}px`;
        marker.textContent = formatSeconds(t);
        bgmMarkers.appendChild(marker);
      }
    };

    const layoutToJson = () => ({
      version: 1,
      segments: [
        ...bgmSegments.map((segment) => ({
          file: segment.file || bgmUploadPath,
          name: segment.name,
          start: segment.start,
          end: segment.end,
          offset: segment.offset,
          volume: segment.volume,
          fade_in: segment.fadeIn,
          fade_out: segment.fadeOut,
        })),
        ...sfxSegments.map((segment) => ({
          file: segment.file,
          name: segment.name,
          start: segment.start,
          end: segment.end,
          offset: segment.offset,
          volume: segment.volume,
          fade_in: segment.fadeIn,
          fade_out: segment.fadeOut,
        })),
      ],
    });

    const persistLayout = async () => {
      try {
        const bgmReady = bgmSegments.length === 0 || bgmSegments.every((segment) => segment.file || bgmUploadPath);
        const sfxReady = sfxSegments.length === 0 || sfxSegments.every((segment) => segment.file);
        const canPersist = (bgmSegments.length + sfxSegments.length) > 0 && bgmReady && sfxReady;
        if (!canPersist) {
          return;
        }
        await fetch("/api/bgm/layout", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(layoutToJson()),
        });
      } catch (err) {
        console.error(err);
      }
    };

    const selectBgm = (id) => {
      selectedBgmId = id;
      document.querySelectorAll(".bgm-segment, .sfx-segment").forEach((el) => {
        el.classList.toggle("selected", el.dataset.id === String(id));
      });
      const segment = bgmSegments.find((item) => item.id === id)
        || sfxSegments.find((item) => item.id === id);
      if (!segment) {
        bgmStartEl.textContent = "--:--.--";
        bgmEndEl.textContent = "--:--.--";
      bgmVolumeEl.disabled = true;
      bgmFadeInEl.disabled = true;
      bgmFadeOutEl.disabled = true;
      selectedBlock = null;
      console.log("Selection cleared: none");
      updateMixAvailability();
      return;
      }
      bgmStartEl.textContent = formatTime(segment.start);
      bgmEndEl.textContent = formatTime(segment.end);
      bgmVolumeEl.value = segment.volume;
      bgmFadeInEl.value = segment.fadeIn;
      bgmFadeOutEl.value = segment.fadeOut;
      bgmVolumeEl.disabled = false;
      bgmFadeInEl.disabled = false;
      bgmFadeOutEl.disabled = false;
      if (segment.track === "sfx") {
        selectedBlock = {
          type: "sfx",
          startTime: segment.start,
          duration: Math.max(0, segment.end - segment.start),
          file: segment.file,
          volume: segment.volume,
          fadeIn: segment.fadeIn,
          fadeOut: segment.fadeOut,
          name: segment.name,
        };
        console.log("Block SELECTED and stored:", selectedBlock);
      } else {
        selectedBlock = {
          type: "bgm",
          startTime: segment.start,
          duration: Math.max(0, segment.end - segment.start),
          file: segment.file || bgmUploadPath,
          volume: segment.volume,
          fadeIn: segment.fadeIn,
          fadeOut: segment.fadeOut,
          offset: segment.offset,
          name: segment.name,
        };
        console.log("Block SELECTED and stored:", selectedBlock);
      }
      updateMixAvailability();
      persistLayout();
    };

    const renderBgmSegments = (persist = true) => {
      refreshTimelineWidth();
      bgmLane.innerHTML = "";
      if (sfxLane) {
        sfxLane.innerHTML = "";
      }
      sfxSegments.forEach((segment) => {
        if (!sfxLane) return;
        const el = document.createElement("div");
        el.className = "sfx-segment";
        if (segment.id === selectedBgmId) {
          el.classList.add("selected");
        }
        el.dataset.id = segment.id;
        const left = segment.start * timelinePxPerSec;
        const width = Math.max(18, (segment.end - segment.start) * timelinePxPerSec);
        el.style.left = `${left}px`;
        el.style.width = `${width}px`;
        el.textContent = segment.name;
        segment.element = el;
        const leftHandle = document.createElement("span");
        leftHandle.className = "handle left";
        leftHandle.dataset.handle = "left";
        const rightHandle = document.createElement("span");
        rightHandle.className = "handle right";
        rightHandle.dataset.handle = "right";
        el.appendChild(leftHandle);
        el.appendChild(rightHandle);
        el.addEventListener("mousedown", (event) => {
          event.stopPropagation();
          event.preventDefault();
          selectBgm(segment.id);
          startDrag(event, segment, el);
        });
        el.addEventListener("click", (event) => {
          event.stopPropagation();
          selectBgm(segment.id);
        });
        sfxLane.appendChild(el);
      });
      bgmSegments.forEach((segment) => {
        const el = document.createElement("div");
        el.className = "bgm-segment";
        if (segment.id === selectedBgmId) {
          el.classList.add("selected");
        }
        el.dataset.id = segment.id;
        const left = segment.start * timelinePxPerSec;
        const width = Math.max(24, (segment.end - segment.start) * timelinePxPerSec);
        el.style.left = `${left}px`;
        el.style.width = `${width}px`;
        const label = document.createElement("span");
        label.className = "segment-label";
        label.textContent = segment.name;
        el.appendChild(label);
        segment.element = el;
        const leftHandle = document.createElement("span");
        leftHandle.className = "handle left";
        leftHandle.dataset.handle = "left";
        const rightHandle = document.createElement("span");
        rightHandle.className = "handle right";
        rightHandle.dataset.handle = "right";
        el.appendChild(leftHandle);
        el.appendChild(rightHandle);
        const fadeInIndicator = document.createElement("button");
        fadeInIndicator.type = "button";
        fadeInIndicator.className = "fade-indicator fade-in";
        const fadeInValue = document.createElement("span");
        fadeInValue.className = "fade-label";
        const fadeInInput = document.createElement("input");
        fadeInInput.type = "number";
        fadeInInput.min = "0";
        fadeInInput.max = "10";
        fadeInInput.step = "0.1";
        fadeInIndicator.appendChild(fadeInValue);
        fadeInIndicator.appendChild(fadeInInput);
        const fadeOutIndicator = document.createElement("button");
        fadeOutIndicator.type = "button";
        fadeOutIndicator.className = "fade-indicator fade-out";
        const fadeOutValue = document.createElement("span");
        fadeOutValue.className = "fade-label";
        const fadeOutInput = document.createElement("input");
        fadeOutInput.type = "number";
        fadeOutInput.min = "0";
        fadeOutInput.max = "10";
        fadeOutInput.step = "0.1";
        fadeOutIndicator.appendChild(fadeOutValue);
        fadeOutIndicator.appendChild(fadeOutInput);
        const applyFadeIndicator = (indicator, valueEl, inputEl, value, direction) => {
          const numeric = Number(value) || 0;
          valueEl.textContent = direction === "in" ? `◢ ${numeric}s` : `${numeric}s ◣`;
          inputEl.value = numeric.toFixed(1);
          indicator.classList.toggle("is-empty", numeric <= 0);
        };
        const updateFadeVisuals = () => {
          const duration = Math.max(0.1, segment.end - segment.start);
          const fadeIn = Math.max(0, Math.min(10, Number(segment.fadeIn) || 0));
          const fadeOut = Math.max(0, Math.min(10, Number(segment.fadeOut) || 0));
          const fadeInPct = Math.min(1, fadeIn / duration) * 100;
          const fadeOutPct = Math.min(1, fadeOut / duration) * 100;
          el.style.setProperty("--fade-in-pct", `${fadeInPct}%`);
          el.style.setProperty("--fade-out-pct", `${fadeOutPct}%`);
          applyFadeIndicator(fadeInIndicator, fadeInValue, fadeInInput, fadeIn, "in");
          applyFadeIndicator(fadeOutIndicator, fadeOutValue, fadeOutInput, fadeOut, "out");
        };
        const beginEdit = (indicator, inputEl) => {
          indicator.classList.add("editing");
          inputEl.focus();
          inputEl.select();
        };
        const endEdit = (indicator) => {
          indicator.classList.remove("editing");
        };
        fadeInIndicator.addEventListener("click", (event) => {
          event.stopPropagation();
          beginEdit(fadeInIndicator, fadeInInput);
        });
        fadeOutIndicator.addEventListener("click", (event) => {
          event.stopPropagation();
          beginEdit(fadeOutIndicator, fadeOutInput);
        });
        const handleFadeInput = (inputEl, indicator, type) => {
          const numeric = Math.max(0, Math.min(10, parseFloat(inputEl.value || 0)));
          if (type === "in") {
            segment.fadeIn = numeric;
          } else {
            segment.fadeOut = numeric;
          }
          updateFadeVisuals();
          persistLayout();
          if (wavesurfer && wavesurfer.isPlaying()) {
            startPreviewMix(wavesurfer.getCurrentTime());
          }
          endEdit(indicator);
        };
        fadeInInput.addEventListener("change", (event) => {
          event.stopPropagation();
          handleFadeInput(fadeInInput, fadeInIndicator, "in");
        });
        fadeOutInput.addEventListener("change", (event) => {
          event.stopPropagation();
          handleFadeInput(fadeOutInput, fadeOutIndicator, "out");
        });
        fadeInInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            handleFadeInput(fadeInInput, fadeInIndicator, "in");
          }
        });
        fadeOutInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            handleFadeInput(fadeOutInput, fadeOutIndicator, "out");
          }
        });
        fadeInInput.addEventListener("blur", () => endEdit(fadeInIndicator));
        fadeOutInput.addEventListener("blur", () => endEdit(fadeOutIndicator));
        fadeInIndicator.addEventListener("mousedown", (event) => event.stopPropagation());
        fadeOutIndicator.addEventListener("mousedown", (event) => event.stopPropagation());
        el.appendChild(fadeInIndicator);
        el.appendChild(fadeOutIndicator);
        updateFadeVisuals();
        el.addEventListener("mousedown", (event) => {
          event.stopPropagation();
          event.preventDefault();
          selectBgm(segment.id);
          startDrag(event, segment, el);
        });
        el.addEventListener("click", (event) => {
          event.stopPropagation();
          selectBgm(segment.id);
        });
        bgmLane.appendChild(el);
      });
      updateMixAvailability();
      if (
        bgmSegments.find((item) => item.id === selectedBgmId)
        || sfxSegments.find((item) => item.id === selectedBgmId)
      ) {
        selectBgm(selectedBgmId);
      } else {
        selectBgm(null);
      }
      if (persist) {
        persistLayout();
      }
    };

    const startDrag = (event, segment, element) => {
      event.preventDefault();
      const handle = event.target.dataset.handle || "move";
      const startX = event.clientX;
      const originalStart = segment.start;
      const originalEnd = segment.end;
      const originalOffset = segment.offset;
      dragState = { segment, handle, startX, originalStart, originalEnd, originalOffset };
      element.style.cursor = "grabbing";
      document.addEventListener("mousemove", onDragMove);
      document.addEventListener("mouseup", onDragEnd);
    };

    const onDragMove = (event) => {
      if (!dragState) return;
      const delta = (event.clientX - dragState.startX) / timelinePxPerSec;
      const segment = dragState.segment;
      const minLength = 0.1;
      if (dragState.handle === "left") {
        let end = dragState.originalEnd;
        let nextStart = dragState.originalStart + delta;
        nextStart = Math.max(0, Math.min(nextStart, end - minLength));
        let nextOffset = dragState.originalOffset + (nextStart - dragState.originalStart);
        if (nextOffset < 0) {
          nextOffset = 0;
        }
        let nextLength = end - nextStart;
        const maxLength = Math.max(minLength, segment.duration - nextOffset);
        if (nextLength > maxLength) {
          nextLength = maxLength;
          nextStart = end - nextLength;
          nextOffset = dragState.originalOffset + (nextStart - dragState.originalStart);
        }
        segment.start = nextStart;
        segment.end = end;
        segment.offset = Math.max(0, nextOffset);
      } else if (dragState.handle === "right") {
        const maxEndByFile = dragState.originalStart + (segment.duration - dragState.originalOffset);
        const nextEnd = Math.min(
          Math.max(dragState.originalStart + minLength, dragState.originalEnd + delta),
          maxEndByFile
        );
        segment.end = nextEnd;
        segment.offset = dragState.originalOffset;
      } else {
        const duration = dragState.originalEnd - dragState.originalStart;
        const nextStart = Math.max(0, dragState.originalStart + delta);
        segment.start = nextStart;
        segment.end = nextStart + duration;
        segment.offset = dragState.originalOffset;
      }
      if (segment.end < segment.start + minLength) {
        segment.end = segment.start + minLength;
      }
      renderBgmSegments(false);
    };

    const onDragEnd = () => {
      if (!dragState) return;
      dragState = null;
      document.removeEventListener("mousemove", onDragMove);
      document.removeEventListener("mouseup", onDragEnd);
      renderBgmSegments(true);
    };

    const addBgmSegment = (file) => {
      const duration = file.duration || 1;
      const mainDuration = wavesurfer ? wavesurfer.getDuration() || 0 : 0;
      const minLength = 0.1;
      let start = 0;
      let end = Math.max(minLength, duration);
      if (mainDuration) {
        end = Math.max(minLength, Math.min(duration, mainDuration));
      }
      const segment = {
        id: bgmIdCounter++,
        file: file.file,
        name: file.name,
        start,
        end,
        offset: 0,
        duration,
        volume: bgmDefaultVolume,
        fadeIn: bgmDefaultFade,
        fadeOut: bgmDefaultFade,
        track: "bgm",
      };
      bgmSegments.push(segment);
      renderBgmSegments();
      selectBgm(segment.id);
    };

    const addSfxSegment = (file) => {
      const duration = file.duration || 1;
      const mainDuration = wavesurfer ? wavesurfer.getDuration() || 0 : 0;
      const minLength = 0.05;
      let start = 0;
      let end = Math.max(minLength, duration);
      if (mainDuration) {
        end = Math.max(minLength, Math.min(duration, mainDuration));
      }
      const segment = {
        id: bgmIdCounter++,
        file: file.file,
        name: file.name,
        start,
        end,
        offset: 0,
        duration,
        volume: bgmDefaultVolume,
        fadeIn: bgmDefaultFade,
        fadeOut: bgmDefaultFade,
        track: "sfx",
      };
      sfxSegments.push(segment);
      renderBgmSegments();
      selectBgm(segment.id);
    };

    const initBgmWaveform = (file) => {
      if (bgmWaveSurfer) {
        bgmWaveSurfer.destroy();
      }
      if (bgmObjectUrl) {
        URL.revokeObjectURL(bgmObjectUrl);
      }
      updateBgmWaveformWidth();
      bgmObjectUrl = URL.createObjectURL(file);
      bgmWaveSurfer = WaveSurfer.create({
        container: "#bgmWaveform",
        waveColor: "#14532d",
        progressColor: "#22c55e",
        cursorColor: "transparent",
        height: 64,
        normalize: true,
        pixelRatio: window.devicePixelRatio || 1,
        interact: false,
      });
      bgmWaveSurfer.on("ready", () => {
        bgmWaveSurfer.zoom(zoomLevel);
      });
      bgmWaveSurfer.load(bgmObjectUrl);
    };

    const updateMixAvailability = () => {
      mixBgmBtn.disabled = !autoMode || !hasVoiceAudio;
      if (!autoMode) {
        mixBgmBtn.title = "自動録音でのみ書き出しできます。";
      } else if (!hasVoiceAudio) {
        mixBgmBtn.title = "書き出す音声がありません。";
      } else {
        mixBgmBtn.title = "";
      }
    };

    const updateBgmWaveformWidth = () => {
      if (!bgmWaveformEl) return;
      if (!bgmDuration) {
        bgmWaveformEl.style.width = "0px";
        return;
      }
      bgmWaveformEl.style.width = `${bgmDuration * timelinePxPerSec}px`;
    };

    const ensureBgmUpload = async () => {
      if (!bgmFile) {
        throw new Error("BGMが読み込まれていません。");
      }
      if (bgmUploadPath) return bgmUploadPath;
      const uploaded = await uploadBgmFile(bgmFile);
      bgmUploadPath = uploaded.file;
      bgmSegments.forEach((segment) => {
        segment.file = bgmUploadPath;
      });
      return bgmUploadPath;
    };

    const uploadBgmFile = async (file) => {
      const res = await fetch("/api/bgm/upload", {
        method: "POST",
        headers: { "X-File-Name": encodeURIComponent(file.name) },
        body: file,
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || `Upload failed (${res.status})`);
      }
      return res.json();
    };

    const stopPreviewMix = () => {
      previewSources.forEach((source) => {
        try {
          source.stop(0);
        } catch (err) {
          // ignore
        }
      });
      previewSources = [];
      if (previewContext && previewContext.state === "running") {
        previewContext.suspend().catch(() => {});
      }
    };

    const readDuration = (file) => new Promise((resolve, reject) => {
      const audio = document.createElement("audio");
      const tempUrl = URL.createObjectURL(file);
      audio.preload = "metadata";
      audio.onloadedmetadata = () => {
        URL.revokeObjectURL(tempUrl);
        resolve(audio.duration || 0);
      };
      audio.onerror = () => {
        URL.revokeObjectURL(tempUrl);
        reject(new Error("音声メタデータを読み取れませんでした。"));
      };
      audio.src = tempUrl;
    });

      const updatePlayheadUI = (time) => {
        if (!wavesurfer) return;
        const duration = wavesurfer.getDuration() || 0;
        if (!duration) return;
        const clamped = Math.max(0, Math.min(time, duration));
        const left = clamped * timelinePxPerSec;
        if (voicePlayhead) {
          voicePlayhead.style.left = `${left}px`;
        }
        if (bgmPlayhead) {
          bgmPlayhead.style.left = `${left}px`;
        }
        if (currentTimeEl) {
          currentTimeEl.textContent = formatTime(clamped);
        }
      };

    const positionRecordingOverlay = () => {
      if (!recordingActive) return;
      const modalMode = recordingMode;
      let top = "50%";
      let left = "50%";
      let translateX = "-50%";
      let translateY = "-50%";
      let width = "300px";
      let height = "200px";
      if (!hasVoiceAudio) {
        width = "400px";
        height = "200px";
      }
      if (modalMode === "punch" && activeRegion) {
        const regionEl = activeRegion.element || activeRegion.el;
        if (regionEl) {
          const regionRect = regionEl.getBoundingClientRect();
          const gap = 12;
          const modalHeight = 200;
          const desiredTop = regionRect.top - gap - modalHeight;
          const clampedTop = Math.max(16, desiredTop);
          top = `${clampedTop}px`;
          left = `${Math.max(16, Math.min(window.innerWidth - 16, regionRect.left + regionRect.width / 2))}px`;
          translateX = "-50%";
          translateY = "0";
        }
      }
      editorEl.style.setProperty("--recording-modal-top", top);
      editorEl.style.setProperty("--recording-modal-left", left);
      editorEl.style.setProperty("--recording-modal-translate-x", translateX);
      editorEl.style.setProperty("--recording-modal-translate-y", translateY);
      editorEl.style.setProperty("--recording-modal-width", width);
      editorEl.style.setProperty("--recording-modal-height", height);
    };

    const stopRecording = async () => {
      if (!recordingActive) return;
      console.log("recording stop");
      recordingActive = false;
      recordingDirty = true;
      updateRecordingUI();
      stopRecordingAnimation();
      if (mediaRecorder && mediaRecorder.state !== "inactive") {
        mediaRecorder.stop();
      }
    };

    const startRecording = async (mode = "new") => {
      if (recordingActive) return;
      console.log("recording start", mode);
      if (mode === "punch") {
        if (selection.start !== null && selection.end !== null) {
          punchSelection = { start: selection.start, end: selection.end };
        } else {
          const insertAt = getPlaybackTime();
          punchSelection = { start: insertAt, end: insertAt };
        }
      } else if (mode === "insert") {
        const insertAt = getPlaybackTime();
        punchSelection = { start: insertAt, end: insertAt };
      }
      recordingFocusTime = (mode === "punch" || mode === "insert") && punchSelection
        ? punchSelection.start
        : getPlaybackTime();
      if (wavesurfer && wavesurfer.isPlaying()) {
        wavesurfer.pause();
      }
      updatePlayControls();
      recordingMode = mode;
      try {
        recordingStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (err) {
        updateStatus("マイクへのアクセスが拒否されました。", true);
        return;
      }
      if (!recordingStream) {
        updateStatus("マイク入力が取得できません。", true);
        return;
      }
      recordingChunks = [];
      mediaRecorder = new MediaRecorder(recordingStream, recordingMimeType ? { mimeType: recordingMimeType } : undefined);
      mediaRecorder.addEventListener("dataavailable", (event) => {
        if (event.data && event.data.size > 0) {
          recordingChunks.push(event.data);
        }
      });
      mediaRecorder.addEventListener("stop", async () => {
        console.log("=== RECORDING STOPPED ===");
        console.log(
          "mode:",
          recordingMode === "punch" ? "punch-in" : (recordingMode === "insert" ? "insert" : "new")
        );
        if (!recordingChunks.length) {
          updateStatus("録音が空でした。", true);
          await stopRecordingStream();
          recordingMode = "new";
          punchSelection = null;
          recordingDirty = false;
          return;
        }
        const blob = new Blob(recordingChunks, recordingMimeType ? { type: recordingMimeType } : undefined);
        const elapsedSeconds = Math.max(0, (Date.now() - recordingStartTime) / 1000);
        const skipDecode = recordingMode === "new" && elapsedSeconds >= LONG_RECORDING_SECONDS;
        try {
          if (skipDecode) {
            updateStatus("長時間録音のため直接保存します。");
            const extension = mimeTypeToExtension(blob.type || recordingMimeType) || "webm";
            await uploadRecording(blob, getAutoRecordingFileName(extension), false);
            await reloadAutoForced(0, false, "/api/auto", true);
          } else {
            updateStatus("録音を処理中…");
            const arrayBuffer = await blob.arrayBuffer();
            const audioContext = new AudioContext();
            try {
              const decoded = await audioContext.decodeAudioData(arrayBuffer.slice(0));
              console.log("recording decoded", {
                duration: decoded.duration,
                sampleRate: decoded.sampleRate,
                channels: decoded.numberOfChannels,
              });
              const wavBlob = encodeWav(decoded);
              console.log("recording wav", { size: wavBlob.size, type: wavBlob.type });
            if ((recordingMode === "punch" || recordingMode === "insert") && punchSelection) {
              const insertSeekTime = recordingMode === "insert"
                ? punchSelection.start + decoded.duration
                : null;
              console.log("calling endpoint:", "/api/punch");
              await punchInRecording(wavBlob, punchSelection.start, punchSelection.end, insertSeekTime);
            } else {
              console.log("calling endpoint:", "/api/upload");
              await uploadRecording(wavBlob, getAutoRecordingFileName("wav"));
            }
            } catch (decodeError) {
              if (recordingMode === "punch" || recordingMode === "insert") {
                throw decodeError;
              }
              updateStatus("長時間録音のため直接保存します。");
              const extension = mimeTypeToExtension(blob.type || recordingMimeType) || "webm";
              await uploadRecording(blob, getAutoRecordingFileName(extension), false);
              await reloadAutoForced(0, false, "/api/auto", true);
            } finally {
              await audioContext.close();
            }
          }
          await stopRecordingStream();
          recordingMode = "new";
          punchSelection = null;
          recordingDirty = false;
        } catch (err) {
          console.error(err);
          updateStatus(`録音に失敗しました: ${err.message}`, true);
          await stopRecordingStream();
          recordingMode = "new";
          punchSelection = null;
          recordingDirty = true;
        }
      });
      recordingAudioContext = new AudioContext();
      if (recordingAudioContext.state === "suspended") {
        await recordingAudioContext.resume();
      }
      recordingAnalyser = recordingAudioContext.createAnalyser();
      recordingAnalyser.fftSize = 2048;
      recordingSource = recordingAudioContext.createMediaStreamSource(recordingStream);
      recordingSource.connect(recordingAnalyser);
      resizeRecordingCanvas();
      recordingActive = true;
      recordingStartTime = Date.now();
      recordTimer.textContent = "00:00";
      updateRecordingUI();
      updateRecordingTimer();
      drawRecordingWaveform();
      mediaRecorder.start();
    };

    const stopPlayback = () => {
      if (!wavesurfer) return;
      wavesurfer.pause();
      seekToTime(0);
      stopPreviewMix();
      updatePlayControls();
    };

    window.addEventListener("beforeunload", (event) => {
      if (!recordingActive && !recordingDirty) return;
      event.preventDefault();
      event.returnValue = "";
    });

    const getPlaybackTime = () => (wavesurfer ? wavesurfer.getCurrentTime() : 0);

    const clearSelection = () => {
      selection = { start: null, end: null };
      if (activeRegion) {
        activeRegion.remove();
        activeRegion = null;
      }
      updateSelectionUI();
    };

    const setSelectionPoint = (point, time) => {
      selection[point] = time;
      if (selection.start !== null && selection.end !== null) {
        const start = Math.min(selection.start, selection.end);
        const end = Math.max(selection.start, selection.end);
        selection = { start, end };
        if (activeRegion) {
          activeRegion.remove();
        }
        activeRegion = regions.addRegion({
          start,
          end,
          color: "rgba(96, 165, 250, 0.25)",
          drag: true,
          resize: true,
        });
      }
      updateSelectionUI();
    };

    const detachHiddenFileInputs = () => {
      if (document.activeElement === bgmInput) {
        bgmInput.blur();
      }
      if (document.activeElement === sfxInput) {
        sfxInput.blur();
      }
      if (document.activeElement === fileInput) {
        fileInput.blur();
      }
    };


    const toggleStatus = () => {
      editorEl.classList.toggle("show-status");
      statusAutoVisible = false;
      if (statusAutoHideTimeout) {
        clearTimeout(statusAutoHideTimeout);
        statusAutoHideTimeout = null;
      }
    };

    const showControls = () => {
      editorEl.classList.add("show-controls");
      if (showControlsTimeout) {
        clearTimeout(showControlsTimeout);
      }
      showControlsTimeout = setTimeout(() => editorEl.classList.remove("show-controls"), 2500);
    };

    const toggleShortcuts = () => {
      editorEl.classList.toggle("show-shortcuts");
    };

    const clampTime = (time) => {
      if (!wavesurfer) return 0;
      const duration = wavesurfer.getDuration() || 0;
      return Math.max(0, Math.min(time, duration));
    };

    const seekToTime = (time) => {
      if (!wavesurfer) return;
      const duration = wavesurfer.getDuration() || 0;
      if (!duration) return;
      const clamped = clampTime(time);
      updatePlayheadUI(clamped);
      previewStartOffset = clamped;
      wavesurfer.seekTo(clamped / duration);
    };

    const seekBy = (delta) => {
      if (!wavesurfer) return;
      const current = getPlaybackTime();
      seekToTime(current + delta);
    };

    const initWaveform = (blob, label, isAuto, preserveLayout = false) => {
      if (wavesurfer) {
        wavesurfer.destroy();
      }
      if (activeObjectUrl) {
        URL.revokeObjectURL(activeObjectUrl);
      }
      console.log("initWaveform", { size: blob.size, type: blob.type, label, isAuto });
      autoMode = isAuto;
      fileLabel.textContent = label || (isAuto ? "auto" : "読み込み済み");
      hasVoiceAudio = true;
      updateEmptyState();
      if (!preserveLayout) {
      bgmSegments = [];
      sfxSegments = [];
        selectedBgmId = null;
        bgmFile = null;
        bgmUploadPath = null;
        bgmDuration = 0;
        previewBgmBuffer = null;
        previewSfxBuffers = new Map();
        if (bgmWaveSurfer) {
          bgmWaveSurfer.destroy();
          bgmWaveSurfer = null;
        }
        if (bgmObjectUrl) {
          URL.revokeObjectURL(bgmObjectUrl);
          bgmObjectUrl = null;
        }
        bgmWaveformEl.style.width = "0px";
        bgmFileLabel.textContent = "BGM未読込";
        bgmPanel.classList.remove("bgm-loaded");
      }
      updateBgmPlaceholder();
      renderBgmSegments(false);
      selection = { start: null, end: null };
      activeRegion = null;
      updateSelectionUI();
      zoomLevel = 1;
      zoomBase = 1;
      zoomLevelEl.textContent = "--";
      resetZoomBtn.disabled = true;

      regions = WaveSurfer.Regions.create();
      wavesurfer = WaveSurfer.create({
        container: "#waveform",
        waveColor: "#4a9eff",
        progressColor: "#1e5aa8",
        cursorColor: "transparent",
        height: 160,
        normalize: true,
        pixelRatio: window.devicePixelRatio || 1,
        minPxPerSec: 50,
        plugins: [regions],
      });

      wavesurfer.on("ready", () => {
        console.log("VOICE duration:", wavesurfer.getDuration());
        wavesurfer.setVolume(1);
        const duration = wavesurfer.getDuration() || 1;
        durationEl.textContent = formatTime(duration);
        const wrapWidth = waveformWrap.clientWidth || 1;
        zoomBase = Math.max(1, Math.floor(wrapWidth / duration));
        applyZoom(zoomBase);
        updateTimelineScale();
        refreshTimelineWidth();
        const message = "再生はスペースキー";
        updateStatus(message);
        updatePlayheadUI(0);
        updatePlayControls();
        updateMixAvailability();
        if (pendingSeekTime !== null) {
          seekToTime(pendingSeekTime);
          pendingSeekTime = null;
        }
        if (pendingPlay) {
          wavesurfer.play();
          pendingPlay = false;
        }
      });

      wavesurfer.on("timeupdate", (time) => {
        updatePlayheadUI(time);
      });

      wavesurfer.on("seek", (progress) => {
        const duration = wavesurfer.getDuration() || 0;
        const time = duration * progress;
        console.log("seek", time);
        updatePlayheadUI(time);
        previewStartOffset = time;
        if (wavesurfer.isPlaying()) {
          startPreviewMix(time);
        }
      });

      wavesurfer.on("click", (progress) => {
        const duration = wavesurfer.getDuration() || 0;
        const time = duration * progress;
        console.log("seek", time);
        updatePlayheadUI(time);
        previewStartOffset = time;
        if (duration) {
          wavesurfer.seekTo(time / duration);
        }
      });

      wavesurfer.on("audioprocess", (time) => {
        console.log("audioprocess", time);
      });

      wavesurfer.on("play", () => {
        console.log("wavesurfer play");
        startPreviewMix(wavesurfer.getCurrentTime());
        updatePlayControls();
      });

      wavesurfer.on("pause", () => {
        console.log("wavesurfer pause");
        stopPreviewMix();
        updatePlayControls();
      });

      wavesurfer.on("finish", () => {
        console.log("finish", wavesurfer.getDuration());
        stopPreviewMix();
        updatePlayheadUI(wavesurfer.getDuration());
        updatePlayControls();
      });

      regions.enableDragSelection({
        color: "rgba(96, 165, 250, 0.25)",
      });

      regions.on("region-created", (region) => {
        if (activeRegion && activeRegion.id !== region.id) {
          activeRegion.remove();
        }
        region.element = region.element || region.el || region.wrapper;
        activeRegion = region;
        activeRegion.setOptions({ drag: true, resize: true });
        selection = { start: region.start, end: region.end };
        updateSelectionUI();
      });

      regions.on("region-updated", (region) => {
        if (!activeRegion || activeRegion.id !== region.id) return;
        region.element = region.element || region.el || region.wrapper;
        selection = { start: region.start, end: region.end };
        updateSelectionUI();
      });

      regions.on("region-removed", (region) => {
        if (activeRegion && activeRegion.id === region.id) {
          activeRegion = null;
          selection = { start: null, end: null };
          updateSelectionUI();
        }
      });

      activeObjectUrl = URL.createObjectURL(blob);
      console.log("wavesurfer.load", { objectUrl: activeObjectUrl, label, isAuto });
      wavesurfer.load(activeObjectUrl);
    };

    const loadFromUrl = async (url, label, isAuto, seekTime = null, play = false, preserveLayout = false) => {
      try {
        updateStatus("読み込み中…");
        console.log("loadFromUrl fetch", { url, label, isAuto });
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) {
          if (isAuto && res.status === 404) {
            hasVoiceAudio = false;
            updateMixAvailability();
            updateStatus("準備完了");
            updateEmptyState();
            if (preserveLayout) {
              renderBgmSegments(false);
            }
            return;
          }
          throw new Error(`Failed to load ${url}`);
        }
        const blob = await res.blob();
        console.log("loadFromUrl blob", { size: blob.size, type: blob.type });
        const headerBuffer = await blob.slice(0, 12).arrayBuffer();
        console.log("loadFromUrl blob header", { bytes: Array.from(new Uint8Array(headerBuffer)) });
        pendingSeekTime = seekTime;
        pendingPlay = play;
        initWaveform(blob, label, isAuto, preserveLayout);
        updatePlayControls();
      } catch (err) {
        console.error(err);
        updateStatus(`読み込みに失敗しました: ${err.message}`, true);
      }
    };

    const reloadAuto = async (seekTime, play, url = "/api/auto", preserveLayout = true) => {
      if (!autoMode) {
        updateStatus("自動録音のみ削除できます。", true);
        return;
      }
      if (typeof url !== "string" || !url) {
        url = "auto.wav";
      }
      const cacheBust = `${url}${url.includes("?") ? "&" : "?"}t=${Date.now()}`;
      console.log("reloadAuto", { cacheBust, seekTime, play });
      stopPreviewMix();
      if (wavesurfer) {
        wavesurfer.pause();
        wavesurfer.empty?.();
      }
      if (activeObjectUrl) {
        URL.revokeObjectURL(activeObjectUrl);
        activeObjectUrl = null;
      }
      await loadFromUrl(cacheBust, "auto", true, seekTime, play, preserveLayout);
    };

    const reloadAutoForced = async (seekTime, play, url = "/api/auto", preserveLayout = true) => {
      autoMode = true;
      console.log("reloadAutoForced");
      await reloadAuto(seekTime, play, url, preserveLayout);
    };

    const deleteSelection = async () => {
      console.log("deleteSelection called", { selection, autoMode, busy });
      if (busy) return;
      if (!selection.start && selection.start !== 0 || selection.end === null) {
        updateStatus("範囲が選択されていません。", true);
        return;
      }
      if (!autoMode) {
        console.log("deleteSelection skipping server delete (non-auto mode)");
        clearSelection();
        updateStatus("選択を解除しました。");
        return;
      }
      const start = selection.start;
      const end = selection.end;
      const duration = end - start;
      if (duration <= 0) {
        updateStatus("範囲が不正です。", true);
        return;
      }
      console.log("deleteSelection range", { start, end, duration });
      const currentTime = getPlaybackTime();
      const wasPlaying = wavesurfer.isPlaying();
      let targetTime = currentTime;
      if (currentTime > end) {
        targetTime = currentTime - duration;
      } else if (currentTime >= start && currentTime <= end) {
        targetTime = start;
      }
      busy = true;
      wavesurfer.pause();
      updateStatus("削除中…");
      try {
        console.log("deleteSelection sending request", { start, end });
        const res = await fetch("/api/delete", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ start, end }),
        });
        console.log("deleteSelection response", { ok: res.ok, status: res.status });
        if (!res.ok) {
          const text = await res.text();
          console.log("deleteSelection response text", text);
          throw new Error(text || `HTTP ${res.status}`);
        }
        console.log("deleteSelection clearing selection + reload");
        clearSelection();
        await reloadAuto(targetTime, wasPlaying, "/api/auto", true);
      updateStatus("削除しました。");
      } catch (err) {
        console.error(err);
        updateStatus(`削除に失敗しました: ${err.message}`, true);
      } finally {
        busy = false;
      }
    };

    const undoDelete = async () => {
      if (busy) return;
      if (!autoMode) {
        updateStatus("自動録音のみ元に戻せます。", true);
        return;
      }
      const currentTime = getPlaybackTime();
      const wasPlaying = wavesurfer.isPlaying();
      busy = true;
      wavesurfer.pause();
      updateStatus("復元中…");
      try {
        const res = await fetch("/api/undo", { method: "POST" });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || `HTTP ${res.status}`);
        }
        clearSelection();
        await reloadAuto(currentTime, wasPlaying, "/api/auto", true);
        updateStatus("復元しました。");
      } catch (err) {
        console.error(err);
        updateStatus(`復元に失敗しました: ${err.message}`, true);
      } finally {
        busy = false;
      }
    };

    if (fileInput) {
      fileInput.addEventListener("change", (evt) => {
        const file = evt.target.files?.[0];
        if (!file) return;
        fileInput.blur();
      const formData = new FormData();
      formData.append("file", file, file.name);
      updateStatus("アップロード中…");
      fetch("/api/upload", { method: "POST", body: formData })
        .then((res) => {
          if (!res.ok) {
            return res.text().then((text) => {
              throw new Error(text || `Upload failed (${res.status})`);
            });
          }
          return res.json();
        })
        .then(() => {
          updateStatus("アップロード完了。");
          previewStartOffset = 0;
          reloadAutoForced(0, false, "/api/auto", true);
        })
        .catch((err) => {
          console.error(err);
          updateStatus(`アップロードに失敗しました: ${err.message}`, true);
        });
        showControls();
      });
    }

    if (resetZoomBtn) {
      resetZoomBtn.addEventListener("click", () => {
        if (!wavesurfer) return;
        resetZoom();
      });
    }

    if (waveformWrap) {
      waveformWrap.addEventListener("click", () => {
        if (recordingActive || hasVoiceAudio || wavesurfer) return;
        if (recordBtn.disabled) {
          updateStatus("録音はこのブラウザで利用できません。", true);
          return;
        }
        startRecording();
        showControls();
      });
    }

    if (emptyRecordBtn) {
      emptyRecordBtn.addEventListener("click", () => {
        if (recordBtn.disabled) {
          updateStatus("録音はこのブラウザで利用できません。", true);
          return;
        }
        if (recordingActive) return;
        recordingMode = "new";
        startRecording("new");
        showControls();
      });
    }

    if (recordBtn) {
      recordBtn.addEventListener("click", () => {
        if (recordBtn.disabled) {
          updateStatus("録音はこのブラウザで利用できません。", true);
          return;
        }
        if (recordingActive) return;
        startRecording(recordingMode === "punch" ? "punch" : "new");
        showControls();
      });
    }

    if (recordStopBtn) {
      recordStopBtn.addEventListener("click", () => {
        if (recordingActive) {
          stopRecording();
        }
        showControls();
      });
    }

    if (punchBtn) {
      punchBtn.addEventListener("click", () => {
        if (recordBtn.disabled) {
          updateStatus("録音はこのブラウザで利用できません。", true);
          return;
        }
        if (recordingActive) {
          stopRecording();
          return;
        }
        if (selection.start === null || selection.end === null) {
          updateStatus("差し替えたい範囲を選択してください。", true);
          return;
        }
        startRecording("punch");
        showControls();
      });
    }

    if (playBtn) {
      playBtn.addEventListener("click", () => {
        if (!wavesurfer) {
          updateStatus("VOICEを読み込んでください。", true);
          return;
        }
        if (wavesurfer.isPlaying()) {
          wavesurfer.pause();
        } else {
          wavesurfer.play();
        }
        updatePlayControls();
        showControls();
      });
    }

    if (stopBtn) {
      stopBtn.addEventListener("click", () => {
        if (recordingActive) {
          stopRecording();
          return;
        }
        if (!wavesurfer) return;
        stopPlayback();
        showControls();
      });
    }

    if (filePickerBtn) {
      filePickerBtn.addEventListener("click", () => {
        fileInput.click();
        showControls();
      });
    }

    if (bgmPickerBtn) {
      bgmPickerBtn.addEventListener("click", () => {
        bgmInput.click();
        showControls();
      });
    }



    if (waveformWrap) {
      waveformWrap.addEventListener("wheel", (event) => {
        if (!wavesurfer) return;
        if (!event.ctrlKey) return;
        event.preventDefault();
        const direction = event.deltaY < 0 ? 1 : -1;
        const step = Math.max(5, Math.round(zoomLevel * 0.1));
        const next = Math.max(zoomBase, zoomLevel + direction * step);
        applyZoom(next);
      }, { passive: false });
    }

    if (editorEl) {
      editorEl.addEventListener("mousemove", (event) => {
        if (recordingActive) return;
        const rect = editorEl.getBoundingClientRect();
        if (rect.bottom - event.clientY < 120) {
          showControls();
        }
      });
    }

    if (waveformWrap) {
      waveformWrap.addEventListener("mousemove", (event) => {
        const rect = waveformWrap.getBoundingClientRect();
        const nearTop = event.clientY - rect.top <= 32;
        waveformWrap.classList.toggle("show-zoom", nearTop);
      });
    }

    if (waveformWrap) {
      waveformWrap.addEventListener("mouseleave", () => {
        waveformWrap.classList.remove("show-zoom");
      });
    }

    if (waveformWrap) {
      waveformWrap.addEventListener("scroll", () => {
        if (syncingScroll) return;
        syncingScroll = true;
        bgmTimelineWrap.scrollLeft = waveformWrap.scrollLeft;
        syncingScroll = false;
        if (recordingActive) {
          // overlay is fixed in corner; no position update needed
        }
      });
    }

    if (bgmTimelineWrap) {
      bgmTimelineWrap.addEventListener("scroll", () => {
        if (syncingScroll) return;
        syncingScroll = true;
        waveformWrap.scrollLeft = bgmTimelineWrap.scrollLeft;
        syncingScroll = false;
        if (recordingActive) {
          // overlay is fixed in corner; no position update needed
        }
      });
    }


    if (bgmTimelineWrap) {
      bgmTimelineWrap.addEventListener("mousedown", (event) => {
        if (!bgmFile && sfxSegments.length === 0) {
          bgmInput.click();
          showControls();
          return;
        }
        if (event.target !== bgmTimelineWrap) return;
        selectBgm(null);
        selectedBlock = null;
        console.log("Selection cleared: clicked background");
        showControls();
      });
    }

    if (bgmVolumeEl) {
      bgmVolumeEl.addEventListener("input", () => {
        const segment = bgmSegments.find((item) => item.id === selectedBgmId)
          || sfxSegments.find((item) => item.id === selectedBgmId);
        if (!segment) return;
        segment.volume = parseFloat(bgmVolumeEl.value);
        persistLayout();
        if (wavesurfer && wavesurfer.isPlaying()) {
          startPreviewMix(wavesurfer.getCurrentTime());
        }
      });
    }

    if (bgmFadeInEl) {
      bgmFadeInEl.addEventListener("change", () => {
        const segment = bgmSegments.find((item) => item.id === selectedBgmId)
          || sfxSegments.find((item) => item.id === selectedBgmId);
        if (!segment) return;
        segment.fadeIn = Math.max(0, parseFloat(bgmFadeInEl.value || 0));
        persistLayout();
        if (wavesurfer && wavesurfer.isPlaying()) {
          startPreviewMix(wavesurfer.getCurrentTime());
        }
      });
    }

    if (bgmFadeOutEl) {
      bgmFadeOutEl.addEventListener("change", () => {
        const segment = bgmSegments.find((item) => item.id === selectedBgmId)
          || sfxSegments.find((item) => item.id === selectedBgmId);
        if (!segment) return;
        segment.fadeOut = Math.max(0, parseFloat(bgmFadeOutEl.value || 0));
        persistLayout();
        if (wavesurfer && wavesurfer.isPlaying()) {
          startPreviewMix(wavesurfer.getCurrentTime());
        }
      });
    }

    const loadPreviewBuffers = async () => {
      if (!previewContext) {
        previewContext = new AudioContext();
      }
      if (!previewBgmBuffer && bgmFile) {
        try {
          const bgmData = await bgmFile.arrayBuffer();
          previewBgmBuffer = await previewContext.decodeAudioData(bgmData.slice(0));
        } catch (err) {
          console.error(err);
          updateStatus("BGMのプレビューを再生できませんでした。", true);
          previewBgmBuffer = null;
        }
      }
      if (sfxSegments.length > 0) {
        const pending = sfxSegments.filter((segment) => segment.file && !previewSfxBuffers.has(segment.file));
        if (pending.length > 0) {
          try {
            const buffers = await Promise.all(
              pending.map(async (segment) => {
                const res = await fetch(segment.file, { cache: "no-store" });
                if (!res.ok) {
                  throw new Error(`SFX fetch failed: ${segment.file}`);
                }
                const data = await res.arrayBuffer();
                const buffer = await previewContext.decodeAudioData(data.slice(0));
                return { file: segment.file, buffer };
              })
            );
            buffers.forEach(({ file, buffer }) => previewSfxBuffers.set(file, buffer));
          } catch (err) {
            console.error(err);
            updateStatus("効果音のプレビューを再生できませんでした。", true);
          }
        }
      }
    };

    const startPreviewMix = async (offsetSeconds = 0) => {
      const hasBgmPreview = bgmFile && bgmSegments.length > 0;
      const hasSfxPreview = sfxSegments.length > 0;
      if (!hasBgmPreview && !hasSfxPreview) {
        return;
      }
      await loadPreviewBuffers();
      if (hasBgmPreview && !previewBgmBuffer) {
        return;
      }
      stopPreviewMix();
      if (previewContext && previewContext.state === "suspended") {
        await previewContext.resume();
      }
      const mixGain = previewContext.createGain();
      mixGain.gain.value = 1;
      mixGain.connect(previewContext.destination);
      const offset = Math.max(0, offsetSeconds);
      if (hasBgmPreview) {
        bgmSegments.forEach((segment) => {
          const segDuration = Math.max(0, segment.end - segment.start);
          if (!segDuration) return;
          const bgmSource = previewContext.createBufferSource();
          bgmSource.buffer = previewBgmBuffer;
          const segmentGain = previewContext.createGain();
          segmentGain.gain.value = Number(segment.volume) || bgmDefaultVolume;
          segmentGain.connect(mixGain);
          const fadeIn = Math.max(0, Math.min(segment.fadeIn, segDuration));
          const fadeOut = Math.max(0, Math.min(segment.fadeOut, segDuration));
          const fadeOutStart = Math.max(0, segDuration - fadeOut);
          const segStart = segment.start;
          if (segStart + segDuration <= offset) return;
          const relativeStart = Math.max(0, segStart - offset);
          const segOffset = Math.max(0, segment.offset + (offset - segStart > 0 ? offset - segStart : 0));
          const playDuration = Math.max(0, segDuration - (offset - segStart > 0 ? offset - segStart : 0));
          if (playDuration <= 0) return;
          const now = previewContext.currentTime + relativeStart;
          segmentGain.gain.setValueAtTime(segmentGain.gain.value, now);
          if (fadeIn > 0) {
            segmentGain.gain.setValueAtTime(0, now);
            segmentGain.gain.linearRampToValueAtTime(segmentGain.gain.value, now + fadeIn);
          }
          if (fadeOut > 0 && playDuration > fadeOutStart) {
            const fadeStart = now + Math.min(playDuration, fadeOutStart);
            segmentGain.gain.setValueAtTime(segmentGain.gain.value, fadeStart);
            segmentGain.gain.linearRampToValueAtTime(0, fadeStart + fadeOut);
          }
          bgmSource.connect(segmentGain);
          bgmSource.start(now, segOffset, playDuration);
          previewSources.push(bgmSource);
        });
      }
      if (hasSfxPreview) {
        sfxSegments.forEach((segment) => {
          const buffer = segment.file ? previewSfxBuffers.get(segment.file) : null;
          if (!buffer) return;
          if (segment.start < offset) return;
          const relativeStart = Math.max(0, segment.start - offset);
          const now = previewContext.currentTime + relativeStart;
          console.log("SFX triggered at", { time: segment.start });
          const sfxSource = previewContext.createBufferSource();
          sfxSource.buffer = buffer;
          const sfxGain = previewContext.createGain();
          sfxGain.gain.value = Number(segment.volume) || bgmDefaultVolume;
          sfxGain.connect(mixGain);
          sfxSource.connect(sfxGain);
          sfxSource.start(now);
          previewSources.push(sfxSource);
        });
      }
      previewGain = mixGain;
    };


    const downloadFile = (fileName) => {
      const downloadUrl = `/api/auto?file=${encodeURIComponent(fileName)}`;
      const link = document.createElement("a");
      link.href = downloadUrl;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      link.remove();
    };

    const getExportFileName = (suffix) => `clipod-${new Date().toISOString().replace(/[:.]/g, "")}-${suffix}.wav`;

    const exportVoiceOnly = async () => {
      const outputName = getExportFileName("voice");
      const res = await fetch("/api/mix", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ output: outputName, use_bgm: false }),
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || `Export failed (${res.status})`);
      }
      const output = await res.json();
      const fileName = output.output || outputName;
      updateStatus(`書き出し完了: ${fileName}`);
      downloadFile(fileName);
    };

    const exportWithBgm = async () => {
      updateStatus("書き出し中…");
      if (bgmFile) {
        await ensureBgmUpload();
      }
      const bgmLayoutSegments = bgmSegments
        .filter((segment) => (segment.end - segment.start) > 0)
        .map((segment) => ({
          ...segment,
          file: segment.file || bgmUploadPath,
          offset: Math.max(0, segment.offset),
          volume: Number(segment.volume) || bgmDefaultVolume,
          fadeIn: Number(segment.fadeIn) || bgmDefaultFade,
          fadeOut: Number(segment.fadeOut) || bgmDefaultFade,
        }));
      const sfxLayoutSegments = sfxSegments
        .filter((segment) => (segment.end - segment.start) > 0)
        .map((segment) => ({
          ...segment,
          file: segment.file,
          offset: Math.max(0, segment.offset),
          volume: Number(segment.volume) || bgmDefaultVolume,
          fadeIn: Number(segment.fadeIn) || bgmDefaultFade,
          fadeOut: Number(segment.fadeOut) || bgmDefaultFade,
        }));
      const segments = [...bgmLayoutSegments, ...sfxLayoutSegments];
      if (segments.length === 0) {
        throw new Error("有効なBGM/SFXがありません。");
      }
      if (segments.some((segment) => !segment.file)) {
        throw new Error("音源ファイルが不足しています。");
      }
      const layout = {
        version: 1,
        segments: segments.map((segment) => ({
          file: segment.file,
          name: segment.name,
          start: segment.start,
          end: segment.end,
          offset: segment.offset,
          volume: segment.volume,
          fade_in: segment.fadeIn,
          fade_out: segment.fadeOut,
        })),
      };
      const res = await fetch("/api/bgm/layout", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(layout),
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || `Layout save failed (${res.status})`);
      }
      const outputName = getExportFileName("mix");
      const mixRes = await fetch("/api/mix", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ output: outputName, use_bgm: true }),
      });
      if (!mixRes.ok) {
        const text = await mixRes.text();
        throw new Error(text || `Mix failed (${mixRes.status})`);
      }
      const output = await mixRes.json();
      const fileName = output.output || outputName;
      updateStatus(`書き出し完了: ${fileName}`);
      downloadFile(fileName);
    };

    if (mixBgmBtn) {
      mixBgmBtn.addEventListener("click", async () => {
        if (!autoMode) {
          updateStatus("自動録音のみ書き出し可能です。", true);
          return;
        }
        if (!hasVoiceAudio) {
          updateStatus("書き出す音声がありません。", true);
          return;
        }
        updateStatus("書き出し中…");
        try {
          if (!bgmFile && bgmSegments.length === 0 && sfxSegments.length === 0) {
            await exportVoiceOnly();
          } else {
            await exportWithBgm();
          }
        } catch (err) {
          console.error(err);
          updateStatus(`書き出しに失敗しました: ${err.message}`, true);
        }
      });
    }

    const handleBgmFile = async (file) => {
      updateStatus("BGMを読み込み中…");
      try {
        const duration = await readDuration(file);
        console.log("BGM duration:", duration);
        bgmFile = file;
        bgmUploadPath = null;
        bgmDuration = duration;
        previewBgmBuffer = null;
        previewSfxBuffers = new Map();
        initBgmWaveform(file);
        addBgmSegment({ name: file.name, duration, file: null });
        refreshTimelineWidth();
        updateMixAvailability();
        bgmFileLabel.textContent = file.name;
        bgmPanel.classList.add("bgm-loaded");
        updateBgmPlaceholder();
        updateStatus("BGM読み込み完了");
      } catch (err) {
        console.error(err);
        updateStatus(`BGM読み込みに失敗しました: ${err.message}`, true);
      }
    };

    const handleSfxFile = async (file) => {
      updateStatus("効果音を読み込み中…");
      try {
        const duration = await readDuration(file);
        console.log("SFX duration:", duration);
        const uploaded = await uploadBgmFile(file);
        addSfxSegment({ name: file.name, duration, file: uploaded.file });
        refreshTimelineWidth();
        updateMixAvailability();
        updateBgmPlaceholder();
        updateStatus("効果音を追加しました。");
      } catch (err) {
        console.error(err);
        updateStatus(`効果音読み込みに失敗しました: ${err.message}`, true);
      }
    };

    if (addBgmBtn) {
      addBgmBtn.addEventListener("click", () => {
        console.log("SFX click", { bgmLoaded: !!bgmFile, segments: bgmSegments.length });
        if (sfxInput) {
          sfxInput.click();
          showControls();
          return;
        }
        console.log("SFX click early return: no sfx input");
        updateStatus("効果音ファイルを選択できません。", true);
      });
    }

    if (bgmInput) {
      bgmInput.addEventListener("change", async (event) => {
        const file = event.target.files?.[0];
        if (!file) return;
        await handleBgmFile(file);
        bgmInput.value = "";
        bgmInput.blur();
        detachHiddenFileInputs();
        showControls();
      });
    }

    if (sfxInput) {
      sfxInput.addEventListener("change", async (event) => {
        const file = event.target.files?.[0];
        if (!file) return;
        await handleSfxFile(file);
        sfxInput.value = "";
        sfxInput.blur();
        detachHiddenFileInputs();
        showControls();
      });
    }

    window.addEventListener("resize", () => {
      resizeRecordingCanvas();
    });

    resizeRecordingCanvas();
    updateRecordingControls();
    updateBgmPlaceholder();
    updateEmptyState();

    if (bgmTimelineWrap) {
      bgmTimelineWrap.addEventListener("dragover", (event) => {
        event.preventDefault();
      });

      bgmTimelineWrap.addEventListener("drop", async (event) => {
        event.preventDefault();
        const file = event.dataTransfer?.files?.[0];
        if (!file) return;
        await handleBgmFile(file);
      });
    }

    document.addEventListener("keydown", (event) => {
      if (event.key === " " && event.target === document.body) {
        event.preventDefault();
      }
      console.log("KEYDOWN:", event.key, event.code, event.target?.tagName);
      if (event.target && ["INPUT", "TEXTAREA", "BUTTON"].includes(event.target.tagName) && event.target.type !== "file") return;
      const key = event.key;
      if (key === "Meta") {
        isMetaDown = true;
      }
      const hasMeta = event.metaKey || isMetaDown;
      const hasCtrl = event.ctrlKey;
      console.log("Key combo:", { hasMeta, hasCtrl, key: event.key, selectedBlock });
      if ((hasMeta || hasCtrl) && key.toLowerCase() === "r") {
        return;
      }
      if (recordingActive && (key.toLowerCase() === "r" || key === " ")) {
        event.preventDefault();
        event.stopPropagation();
        console.log("STOP RECORDING via", key);
        stopRecording();
        return;
      }
      detachHiddenFileInputs();
      if (recordingActive && key !== "r" && key !== "R") {
        return;
      }
      if (key === "r" || key === "R") {
        console.log("=== R KEY PRESSED ===");
        console.log("isRecording:", recordingActive);
        const hasAudio = hasVoiceAudio && !!wavesurfer;
        console.log("hasAudio:", hasAudio, { hasVoiceAudio, hasWavesurfer: !!wavesurfer });
        const hasSelection = selection.start !== null && selection.end !== null;
        console.log("selection:", { start: selection.start, end: selection.end });
        console.log("selection values:", {
          start: selection.start,
          end: selection.end,
          hasSelection,
          startType: typeof selection.start,
          endType: typeof selection.end,
        });
        console.log("recording decision:", hasSelection ? "punch" : (hasAudio ? "insert" : "new"));
        event.preventDefault();
        if (event.repeat) return;
        if (recordBtn && recordBtn.disabled) {
          updateStatus("録音はこのブラウザで利用できません。", true);
          return;
        }
        if (recordingActive) {
          stopRecording();
        } else if (hasSelection) {
          recordingMode = "punch";
          updateRecordingUI();
          startRecording("punch");
        } else if (hasAudio) {
          recordingMode = "insert";
          updateRecordingUI();
          startRecording("insert");
        } else {
          recordingMode = "new";
          updateRecordingUI();
          startRecording("new");
        }
        showControls();
        return;
      }
      if (key === "?") {
        event.preventDefault();
        toggleShortcuts();
        showControls();
        return;
      }
      if ((hasMeta || hasCtrl) && key.toLowerCase() === "c" && !event.repeat) {
        if (selectedBlock) {
          event.preventDefault();
          clipboardSegment = {
            ...selectedBlock,
            originalEndTime: selectedBlock.startTime + selectedBlock.duration,
          };
          copyTime = Date.now();
          console.log("COPIED block", clipboardSegment);
          updateStatus("ブロックをコピーしました。");
          const selected = getSelectedSegment();
          addCopyHighlight(selected);
        } else {
          console.log("No block selected to copy");
          updateStatus("コピーするブロックがありません。", true);
        }
        return;
      }
      if ((hasMeta || hasCtrl) && key.toLowerCase() === "v" && !event.repeat) {
        event.preventDefault();
        if (!clipboardSegment) {
          console.log("No block selected to paste");
          updateStatus("貼り付けるブロックがありません。", true);
          return;
        }
        const currentTime = getPlaybackTime();
        const timeSinceCopy = Date.now() - copyTime;
        const playheadNearCopied = Math.abs(currentTime - clipboardSegment.startTime) < 2;
        let pasteTime = currentTime;
        if (timeSinceCopy < 3000 || playheadNearCopied) {
          pasteTime = (clipboardSegment.originalEndTime ?? clipboardSegment.startTime) + 0.1;
        }
        console.log("PASTE block at", pasteTime, clipboardSegment);
        pasteSegmentAt(clipboardSegment, pasteTime);
        clipboardSegment.originalEndTime = pasteTime + (clipboardSegment.duration || 0);
        updateStatus("ブロックを貼り付けました。");
        showControls();
        return;
      }
      if (key === "e" || key === "E") {
        event.preventDefault();
        mixBgmBtn.click();
        showControls();
        return;
      }
      if (!wavesurfer) return;
      const current = wavesurfer.getCurrentTime();
      if (key === "i" && !event.shiftKey) {
        event.preventDefault();
        toggleStatus();
        showControls();
        return;
      }
        if (key === " ") {
          event.preventDefault();
        if (!hasVoiceAudio) {
          recordingMode = "new";
          updateRecordingUI();
          startRecording("new");
          showControls();
          return;
        }
          if (wavesurfer && wavesurfer.isPlaying()) {
            wavesurfer.pause();
          } else if (wavesurfer) {
            wavesurfer.play();
          }
          showControls();
          return;
        }
      if (key === "I") {
        event.preventDefault();
        setSelectionPoint("start", current);
        showControls();
        return;
      }
      if (key === "O") {
        event.preventDefault();
        setSelectionPoint("end", current);
        showControls();
        return;
      }
      if (key === "d" || key === "D") {
        event.preventDefault();
        if (selection.start !== null && selection.end !== null) {
          deleteSelection();
          showControls();
          return;
        }
        updateStatus("範囲が選択されていません。", true);
        showControls();
        return;
      }
      if (event.metaKey && !event.shiftKey && (key === "z" || key === "Z")) {
        event.preventDefault();
        undoDelete();
        showControls();
        return;
      }
      if (event.metaKey && event.shiftKey && (key === "z" || key === "Z")) {
        event.preventDefault();
        updateStatus("やり直しは未対応です。", true);
        showControls();
        return;
      }
      if (event.metaKey && key === "ArrowLeft") {
        event.preventDefault();
        seekToTime(0);
        showControls();
        return;
      }
      if (event.metaKey && key === "ArrowRight") {
        event.preventDefault();
        seekToTime(wavesurfer.getDuration());
        showControls();
        return;
      }
      if (key === "ArrowLeft") {
        event.preventDefault();
        seekBy(-1);
        showControls();
        return;
      }
      if (key === "ArrowRight") {
        event.preventDefault();
        seekBy(1);
        showControls();
        return;
      }
      if (key === "Escape") {
        event.preventDefault();
        if (recordingActive) {
          stopRecording();
          return;
        }
        clearSelection();
        selectBgm(null);
        selectedBlock = null;
        clipboardSegment = null;
        editorEl.classList.remove("show-status", "show-shortcuts");
        showControls();
        return;
      }
      if (key === "Delete" || key === "Backspace") {
        event.preventDefault();
        if (selection.start !== null && selection.end !== null) {
          deleteSelection();
          showControls();
        }
      }
    }, true);

    document.addEventListener("keyup", (event) => {
      if (event.key === "Meta") {
        isMetaDown = false;
      }
    }, true);

    const params = new URLSearchParams(window.location.search);
    const fileParam = params.get("file");
    const fileParamLower = (fileParam || "").toLowerCase();
    const isAutoFile = fileParamLower === "auto" || fileParamLower.startsWith("auto.");
    if (fileParam) {
      const url = isAutoFile ? "/api/auto" : fileParam;
      loadFromUrl(url, fileParam, isAutoFile, null, false, false);
    }
  </script>
</body>
</html>
