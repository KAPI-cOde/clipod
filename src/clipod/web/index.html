<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>clipod Waveform Editor</title>
  <link rel="preconnect" href="https://unpkg.com" />
  <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
  <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.min.js"></script>
  <style>
    :root {
      color-scheme: dark;
    }
    body {
      margin: 16px;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", sans-serif;
      color: #e5e7eb;
      background: #0b0f14;
    }
    h1 {
      font-size: 18px;
      margin: 0 0 12px;
      font-weight: 600;
      color: #f9fafb;
    }
    .panel {
      background: #111827;
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 12px 16px 16px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
    }
    .panel.selection-active {
      border-color: #60a5fa;
      box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.2);
    }
    .top-row {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      font-size: 12px;
      color: #9ca3af;
    }
    .file-label {
      font-size: 12px;
      color: #d1d5db;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 40%;
    }
    #waveform {
      min-width: 100%;
    }
    #waveformWrap {
      margin-top: 6px;
      overflow-x: auto;
      overflow-y: hidden;
      border: 1px solid #1f2937;
      border-radius: 10px;
      background: #0b1220;
      padding: 6px 0;
      position: relative;
    }
    .voice-header {
      margin-top: 6px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 12px;
      color: #9ca3af;
    }
    .track-label {
      font-weight: 600;
      color: #f9fafb;
      letter-spacing: 0.04em;
    }
    .zoom-indicator strong {
      color: #f9fafb;
      font-weight: 600;
    }
    .status-line {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 12px;
      margin-top: 8px;
      color: #9ca3af;
    }
    .status-line strong {
      color: #f9fafb;
      font-weight: 600;
    }
    .bgm-panel {
      margin: 6px 0 6px;
    }
    .bgm-header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      font-size: 12px;
      color: #9ca3af;
    }
    .bgm-track-label {
      font-weight: 600;
      color: #f9fafb;
    }
    .bgm-file-label {
      font-weight: 600;
      color: #bbf7d0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 240px;
    }
    #bgmTimelineWrap {
      margin-top: 6px;
      overflow-x: auto;
      overflow-y: hidden;
      border: 1px solid #14532d;
      border-radius: 10px;
      background: #0b1612;
      padding: 6px 0;
      position: relative;
    }
    #bgmTimeline {
      position: relative;
      height: 112px;
      min-width: 100%;
    }
    #bgmMarkers {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 20px;
      font-size: 10px;
      color: #6ee7b7;
      pointer-events: none;
      z-index: 2;
    }
    #bgmWaveform {
      position: absolute;
      top: 26px;
      left: 0;
      right: 0;
      height: 64px;
      pointer-events: none;
      opacity: 0.8;
      z-index: 1;
    }
    .bgm-marker {
      position: absolute;
      top: 0;
      transform: translateX(-50%);
      white-space: nowrap;
    }
    #bgmLane {
      position: absolute;
      top: 26px;
      left: 0;
      right: 0;
      height: 64px;
      z-index: 3;
    }
    .bgm-segment {
      position: absolute;
      top: 10px;
      height: 44px;
      border-radius: 8px;
      background: rgba(16, 185, 129, 0.25);
      border: 1px solid #10b981;
      cursor: grab;
      display: flex;
      align-items: center;
      padding: 0 8px;
      font-size: 11px;
      color: #ecfdf5;
      box-sizing: border-box;
      user-select: none;
      z-index: 4;
    }
    .bgm-segment.selected {
      background: rgba(16, 185, 129, 0.45);
      border-color: #34d399;
    }
    .bgm-segment .handle {
      position: absolute;
      top: 0;
      width: 8px;
      height: 100%;
      cursor: ew-resize;
    }
    .bgm-segment .handle.left {
      left: 0;
    }
    .bgm-segment .handle.right {
      right: 0;
    }
    .bgm-info {
      font-size: 12px;
      color: #9ca3af;
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .bgm-info input[type="number"] {
      width: 72px;
      padding: 2px 4px;
      font-size: 12px;
    }
    .bgm-info input[type="range"] {
      width: 140px;
    }
    .bgm-drop {
      margin-top: 6px;
      font-size: 11px;
      color: #6b7280;
    }
    .selection-indicator {
      padding: 2px 6px;
      border-radius: 999px;
      background: #1f2937;
      color: #9ca3af;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .panel.selection-active .selection-indicator {
      background: #60a5fa;
      color: #0b0f14;
    }
    #status {
      margin-top: 8px;
      font-size: 12px;
      color: #93c5fd;
    }
    #status.error {
      color: #fca5a5;
    }
    button {
      border: 1px solid #334155;
      background: #0f172a;
      color: #e5e7eb;
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 8px;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button:not(:disabled):hover {
      border-color: #60a5fa;
      color: #f9fafb;
    }
    .track-playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #fbbf24;
      pointer-events: none;
      z-index: 5;
      opacity: 0.8;
    }
    .bgm-panel:not(.bgm-loaded) #bgmTimelineWrap,
    .bgm-panel:not(.bgm-loaded) .bgm-info {
      display: none;
    }
    .bgm-panel.bgm-loaded .bgm-drop {
      display: none;
    }
    details.shortcuts {
      margin-top: 10px;
      font-size: 12px;
      color: #9ca3af;
      max-width: 640px;
    }
    details.shortcuts summary {
      cursor: pointer;
    }
    details.shortcuts ul {
      margin: 8px 0 0 16px;
      padding: 0;
    }
    details.shortcuts li {
      margin-bottom: 4px;
    }
  </style>
</head>
<body>
  <h1>clipod waveform editor</h1>
  <div class="panel" id="editor">
    <div class="top-row">
      <input type="file" id="fileInput" accept="audio/*" />
      <span class="zoom-indicator">Zoom <strong id="zoomLevel">--</strong> px/s</span>
      <button type="button" id="resetZoom" disabled>Reset Zoom</button>
    </div>
    <div class="voice-header">
      <span class="track-label">VOICE</span>
      <span class="file-label" id="fileLabel">No file loaded</span>
    </div>
    <div id="waveformWrap">
      <div id="waveform"></div>
      <span class="track-playhead" id="voicePlayhead"></span>
    </div>
    <div class="status-line">
      <span>Time <strong id="currentTime">00:00.00</strong></span>
      <span>Sel <strong id="selectionStart">--:--.--</strong>–<strong id="selectionEnd">--:--.--</strong></span>
      <span>Dur <strong id="duration">--:--.--</strong></span>
      <span class="selection-indicator" id="selectionIndicator">No selection</span>
    </div>
    <div id="status">Load an audio file or use ?file=auto.</div>
    <details class="shortcuts">
      <summary>Shortcuts</summary>
      <ul>
        <li><strong>Space</strong>: play/pause</li>
        <li><strong>I</strong>/<strong>O</strong>: set In/Out selection</li>
        <li><strong>D</strong>: delete selection (voice track)</li>
        <li><strong>⌘+Z</strong>: undo delete</li>
        <li><strong>⌘+⇧+Z</strong>: redo (not implemented)</li>
        <li><strong>←</strong>/<strong>→</strong>: nudge playhead</li>
        <li><strong>⌘+←</strong>/<strong>⌘+→</strong>: jump start/end</li>
        <li><strong>Esc</strong>: clear selection</li>
      </ul>
    </details>
    <div class="bgm-panel">
      <div class="bgm-header">
        <span class="bgm-track-label">BGM</span>
        <span class="bgm-file-label" id="bgmFileLabel">♪ No BGM loaded</span>
        <input type="file" id="bgmInput" accept="audio/*" />
        <button type="button" id="addBgm">Add block</button>
        <button type="button" id="mixBgm" disabled>Mix</button>
      </div>
      <div class="bgm-drop">Drag & drop a BGM file onto the timeline to load it.</div>
      <div id="bgmTimelineWrap">
        <div id="bgmTimeline">
          <div id="bgmMarkers"></div>
          <div id="bgmWaveform"></div>
          <span class="track-playhead" id="bgmPlayhead"></span>
          <div id="bgmLane"></div>
        </div>
      </div>
      <div class="bgm-info">
        <span>Start <strong id="bgmStart">--:--.--</strong></span>
        <span>End <strong id="bgmEnd">--:--.--</strong></span>
        <label>Volume <input type="range" id="bgmVolume" min="0" max="1" step="0.05" value="0.25" disabled></label>
        <label>Fade In <input type="number" id="bgmFadeIn" min="0" step="0.1" value="3" disabled></label>
        <label>Fade Out <input type="number" id="bgmFadeOut" min="0" step="0.1" value="3" disabled></label>
      </div>
    </div>
  </div>

  <script>
    const fileInput = document.getElementById("fileInput");
    const fileLabel = document.getElementById("fileLabel");
    const statusEl = document.getElementById("status");
    const currentTimeEl = document.getElementById("currentTime");
    const durationEl = document.getElementById("duration");
    const selectionStartEl = document.getElementById("selectionStart");
    const selectionEndEl = document.getElementById("selectionEnd");
    const selectionIndicatorEl = document.getElementById("selectionIndicator");
    const editorEl = document.getElementById("editor");
    const zoomLevelEl = document.getElementById("zoomLevel");
    const resetZoomBtn = document.getElementById("resetZoom");
    const waveformWrap = document.getElementById("waveformWrap");
    const bgmTimelineWrap = document.getElementById("bgmTimelineWrap");
    const bgmTimeline = document.getElementById("bgmTimeline");
    const bgmLane = document.getElementById("bgmLane");
    const bgmMarkers = document.getElementById("bgmMarkers");
    const bgmWaveformEl = document.getElementById("bgmWaveform");
    const bgmInput = document.getElementById("bgmInput");
    const addBgmBtn = document.getElementById("addBgm");
    const mixBgmBtn = document.getElementById("mixBgm");
    const bgmFileLabel = document.getElementById("bgmFileLabel");
    const bgmPanel = document.querySelector(".bgm-panel");
    const voicePlayhead = document.getElementById("voicePlayhead");
    const bgmPlayhead = document.getElementById("bgmPlayhead");
    const bgmStartEl = document.getElementById("bgmStart");
    const bgmEndEl = document.getElementById("bgmEnd");
    const bgmVolumeEl = document.getElementById("bgmVolume");
    const bgmFadeInEl = document.getElementById("bgmFadeIn");
    const bgmFadeOutEl = document.getElementById("bgmFadeOut");

    let wavesurfer = null;
    let regions = null;
    let activeRegion = null;
    let selection = { start: null, end: null };
    let activeObjectUrl = null;
    let autoMode = false;
    let pendingSeekTime = null;
    let pendingPlay = false;
    let busy = false;
    let zoomBase = 1;
    let zoomLevel = 1;
    let timelinePxPerSec = 1;
    let bgmSegments = [];
    let selectedBgmId = null;
    let bgmIdCounter = 1;
    let dragState = null;
    let syncingScroll = false;
    let bgmFile = null;
    let bgmUploadPath = null;
    let bgmDuration = 0;
    let bgmObjectUrl = null;
    let bgmWaveSurfer = null;
    let previewContext = null;
    let previewStartOffset = 0;
    let previewBgmBuffer = null;
    let previewSources = [];
    let previewGain = null;
    const bgmDefaultVolume = 0.25;
    const bgmDefaultFade = 3;

    const formatSeconds = (value) => {
      if (value === null || Number.isNaN(value)) {
        return "--:--.--";
      }
      const minutes = Math.floor(value / 60);
      const seconds = Math.floor(value % 60);
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
    };

    const formatTime = (value) => {
      if (value === null || Number.isNaN(value)) {
        return "--:--.--";
      }
      const minutes = Math.floor(value / 60);
      const seconds = Math.floor(value % 60);
      const ms = Math.floor((value - Math.floor(value)) * 100);
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}.${String(ms).padStart(2, "0")}`;
    };

    const updateStatus = (text, isError = false) => {
      statusEl.textContent = text;
      statusEl.classList.toggle("error", isError);
    };

    const updateSelectionUI = () => {
      selectionStartEl.textContent = selection.start === null ? "--:--.--" : formatTime(selection.start);
      selectionEndEl.textContent = selection.end === null ? "--:--.--" : formatTime(selection.end);
      const hasSelection = selection.start !== null && selection.end !== null;
      editorEl.classList.toggle("selection-active", hasSelection);
      selectionIndicatorEl.textContent = hasSelection ? "Selection active" : "No selection";
    };

    const updateZoomUI = () => {
      zoomLevelEl.textContent = `${Math.round(zoomLevel)}`;
      resetZoomBtn.disabled = zoomLevel === zoomBase;
    };

    const applyZoom = (value) => {
      if (!wavesurfer) return;
      zoomLevel = Math.max(1, value);
      wavesurfer.zoom(zoomLevel);
      if (bgmWaveSurfer) {
        bgmWaveSurfer.zoom(zoomLevel);
      }
      updateZoomUI();
      updateTimelineScale();
    };

    const resetZoom = () => {
      applyZoom(zoomBase);
      waveformWrap.scrollLeft = 0;
      bgmTimelineWrap.scrollLeft = 0;
    };

    const updateTimelineScale = () => {
      const duration = wavesurfer ? wavesurfer.getDuration() || 0 : 0;
      if (!duration) return;
      timelinePxPerSec = zoomLevel;
      const width = Math.max(waveformWrap.clientWidth, duration * timelinePxPerSec);
      bgmTimeline.style.width = `${width}px`;
      renderMarkers(duration);
      renderBgmSegments(false);
      updateBgmWaveformWidth();
    };

    const renderMarkers = (duration) => {
      bgmMarkers.innerHTML = "";
      if (!duration) return;
      const step = duration <= 60 ? 10 : duration <= 300 ? 30 : 60;
      for (let t = 0; t <= duration; t += step) {
        const marker = document.createElement("div");
        marker.className = "bgm-marker";
        marker.style.left = `${t * timelinePxPerSec}px`;
        marker.textContent = formatSeconds(t);
        bgmMarkers.appendChild(marker);
      }
    };

    const layoutToJson = () => ({
      version: 1,
      segments: bgmSegments.map((segment) => ({
        file: segment.file,
        name: segment.name,
        start: segment.start,
        end: segment.end,
        offset: segment.offset,
        volume: segment.volume,
        fade_in: segment.fadeIn,
        fade_out: segment.fadeOut,
      })),
    });

    const persistLayout = async () => {
      try {
        if (!bgmUploadPath) {
          return;
        }
        await fetch("/api/bgm/layout", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(layoutToJson()),
        });
      } catch (err) {
        console.error(err);
      }
    };

    const selectBgm = (id) => {
      selectedBgmId = id;
      document.querySelectorAll(".bgm-segment").forEach((el) => {
        el.classList.toggle("selected", el.dataset.id === String(id));
      });
      const segment = bgmSegments.find((item) => item.id === id);
      if (!segment) {
        bgmStartEl.textContent = "--:--.--";
        bgmEndEl.textContent = "--:--.--";
      bgmVolumeEl.disabled = true;
      bgmFadeInEl.disabled = true;
      bgmFadeOutEl.disabled = true;
      updateMixAvailability();
      return;
      }
      bgmStartEl.textContent = formatTime(segment.start);
      bgmEndEl.textContent = formatTime(segment.end);
      bgmVolumeEl.value = segment.volume;
      bgmFadeInEl.value = segment.fadeIn;
      bgmFadeOutEl.value = segment.fadeOut;
      bgmVolumeEl.disabled = false;
      bgmFadeInEl.disabled = false;
      bgmFadeOutEl.disabled = false;
      updateMixAvailability();
      persistLayout();
    };

    const renderBgmSegments = (persist = true) => {
      bgmLane.innerHTML = "";
      bgmSegments.forEach((segment) => {
        const el = document.createElement("div");
        el.className = "bgm-segment";
        if (segment.id === selectedBgmId) {
          el.classList.add("selected");
        }
        el.dataset.id = segment.id;
        const left = segment.start * timelinePxPerSec;
        const width = Math.max(24, (segment.end - segment.start) * timelinePxPerSec);
        el.style.left = `${left}px`;
        el.style.width = `${width}px`;
        el.textContent = segment.name;
        segment.element = el;
        const leftHandle = document.createElement("span");
        leftHandle.className = "handle left";
        leftHandle.dataset.handle = "left";
        const rightHandle = document.createElement("span");
        rightHandle.className = "handle right";
        rightHandle.dataset.handle = "right";
        el.appendChild(leftHandle);
        el.appendChild(rightHandle);
        el.addEventListener("mousedown", (event) => startDrag(event, segment, el));
        el.addEventListener("click", (event) => {
          event.stopPropagation();
          selectBgm(segment.id);
        });
        bgmLane.appendChild(el);
      });
      updateMixAvailability();
      if (bgmSegments.find((item) => item.id === selectedBgmId)) {
        selectBgm(selectedBgmId);
      } else {
        selectBgm(null);
      }
      if (persist) {
        persistLayout();
      }
    };

    const startDrag = (event, segment, element) => {
      event.preventDefault();
      const handle = event.target.dataset.handle || "move";
      const startX = event.clientX;
      const originalStart = segment.start;
      const originalEnd = segment.end;
      const originalOffset = segment.offset;
      dragState = { segment, handle, startX, originalStart, originalEnd, originalOffset };
      element.style.cursor = "grabbing";
      document.addEventListener("mousemove", onDragMove);
      document.addEventListener("mouseup", onDragEnd);
    };

    const onDragMove = (event) => {
      if (!dragState) return;
      const delta = (event.clientX - dragState.startX) / timelinePxPerSec;
      const segment = dragState.segment;
      const minLength = 0.1;
      const mainDuration = wavesurfer ? wavesurfer.getDuration() || 0 : 0;
      if (dragState.handle === "left") {
        let end = dragState.originalEnd;
        if (mainDuration) {
          end = Math.min(end, mainDuration);
        }
        let nextStart = dragState.originalStart + delta;
        nextStart = Math.max(0, Math.min(nextStart, end - minLength));
        let nextOffset = dragState.originalOffset + (nextStart - dragState.originalStart);
        if (nextOffset < 0) {
          nextOffset = 0;
        }
        let nextLength = end - nextStart;
        const maxLength = Math.max(minLength, segment.duration - nextOffset);
        if (nextLength > maxLength) {
          nextLength = maxLength;
          nextStart = end - nextLength;
          nextOffset = dragState.originalOffset + (nextStart - dragState.originalStart);
        }
        segment.start = nextStart;
        segment.end = end;
        segment.offset = Math.max(0, nextOffset);
      } else if (dragState.handle === "right") {
        const maxEndByFile = dragState.originalStart + (segment.duration - dragState.originalOffset);
        let maxEnd = maxEndByFile;
        if (mainDuration) {
          maxEnd = Math.min(maxEnd, mainDuration);
        }
        const nextEnd = Math.min(
          Math.max(dragState.originalStart + minLength, dragState.originalEnd + delta),
          maxEnd
        );
        segment.end = nextEnd;
        segment.offset = dragState.originalOffset;
      } else {
        const duration = dragState.originalEnd - dragState.originalStart;
        let maxStart = Infinity;
        if (mainDuration) {
          maxStart = Math.max(0, mainDuration - duration);
        }
        const nextStart = Math.max(0, Math.min(dragState.originalStart + delta, maxStart));
        segment.start = nextStart;
        segment.end = nextStart + duration;
        segment.offset = dragState.originalOffset;
      }
      if (segment.end < segment.start + minLength) {
        segment.end = segment.start + minLength;
      }
      renderBgmSegments(false);
    };

    const onDragEnd = () => {
      if (!dragState) return;
      dragState = null;
      document.removeEventListener("mousemove", onDragMove);
      document.removeEventListener("mouseup", onDragEnd);
      renderBgmSegments(true);
    };

    const addBgmSegment = (file) => {
      const now = wavesurfer ? wavesurfer.getCurrentTime() : 0;
      const duration = file.duration || 1;
      const mainDuration = wavesurfer ? wavesurfer.getDuration() || 0 : 0;
      const minLength = 0.1;
      let start = now;
      let end = now + Math.min(duration, 10);
      if (mainDuration) {
        if (start > mainDuration - minLength) {
          start = Math.max(0, mainDuration - minLength);
        }
        end = Math.min(start + Math.min(duration, 10), mainDuration);
      }
      if (end < start + minLength) {
        end = start + minLength;
      }
      const segment = {
        id: bgmIdCounter++,
        file: file.file,
        name: file.name,
        start,
        end,
        offset: 0,
        duration,
        volume: bgmDefaultVolume,
        fadeIn: bgmDefaultFade,
        fadeOut: bgmDefaultFade,
      };
      bgmSegments.push(segment);
      renderBgmSegments();
      selectBgm(segment.id);
    };

    const initBgmWaveform = (file) => {
      if (bgmWaveSurfer) {
        bgmWaveSurfer.destroy();
      }
      if (bgmObjectUrl) {
        URL.revokeObjectURL(bgmObjectUrl);
      }
      updateBgmWaveformWidth();
      bgmObjectUrl = URL.createObjectURL(file);
      bgmWaveSurfer = WaveSurfer.create({
        container: "#bgmWaveform",
        waveColor: "#14532d",
        progressColor: "#22c55e",
        cursorColor: "transparent",
        height: 64,
        normalize: true,
        interact: false,
      });
      bgmWaveSurfer.on("ready", () => {
        bgmWaveSurfer.zoom(zoomLevel);
      });
      bgmWaveSurfer.load(bgmObjectUrl);
    };

    const updateMixAvailability = () => {
      mixBgmBtn.disabled = !autoMode || bgmSegments.length === 0 || !bgmFile;
    };

    const updateBgmWaveformWidth = () => {
      if (!bgmWaveformEl) return;
      if (!bgmDuration) {
        bgmWaveformEl.style.width = "0px";
        return;
      }
      bgmWaveformEl.style.width = `${bgmDuration * timelinePxPerSec}px`;
    };

    const ensureBgmUpload = async () => {
      if (!bgmFile) {
        throw new Error("No BGM file loaded.");
      }
      if (bgmUploadPath) return bgmUploadPath;
      const uploaded = await uploadBgmFile(bgmFile);
      bgmUploadPath = uploaded.file;
      bgmSegments.forEach((segment) => {
        segment.file = bgmUploadPath;
      });
      return bgmUploadPath;
    };

    const uploadBgmFile = async (file) => {
      const res = await fetch("/api/bgm/upload", {
        method: "POST",
        headers: { "X-File-Name": encodeURIComponent(file.name) },
        body: file,
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || `Upload failed (${res.status})`);
      }
      return res.json();
    };

    const readDuration = (file) => new Promise((resolve, reject) => {
      const audio = document.createElement("audio");
      const tempUrl = URL.createObjectURL(file);
      audio.preload = "metadata";
      audio.onloadedmetadata = () => {
        URL.revokeObjectURL(tempUrl);
        resolve(audio.duration || 0);
      };
      audio.onerror = () => {
        URL.revokeObjectURL(tempUrl);
        reject(new Error("Failed to read audio metadata"));
      };
      audio.src = tempUrl;
    });

    const updatePlayheadUI = (time) => {
      if (!wavesurfer) return;
      const duration = wavesurfer.getDuration() || 0;
      if (!duration) return;
      const clamped = Math.max(0, Math.min(time, duration));
      const left = clamped * timelinePxPerSec;
      voicePlayhead.style.left = `${left}px`;
      bgmPlayhead.style.left = `${left}px`;
      currentTimeEl.textContent = formatTime(clamped);
    };

    const getPlaybackTime = () => (wavesurfer ? wavesurfer.getCurrentTime() : 0);

    const clearSelection = () => {
      selection = { start: null, end: null };
      if (activeRegion) {
        activeRegion.remove();
        activeRegion = null;
      }
      updateSelectionUI();
    };

    const setSelectionPoint = (point, time) => {
      selection[point] = time;
      if (selection.start !== null && selection.end !== null) {
        const start = Math.min(selection.start, selection.end);
        const end = Math.max(selection.start, selection.end);
        selection = { start, end };
        if (activeRegion) {
          activeRegion.remove();
        }
        activeRegion = regions.addRegion({
          start,
          end,
          color: "rgba(96, 165, 250, 0.25)",
          drag: true,
          resize: true,
        });
      }
      updateSelectionUI();
    };

    const detachHiddenFileInputs = () => {
      if (document.activeElement === bgmInput) {
        bgmInput.blur();
      }
      if (document.activeElement === fileInput) {
        fileInput.blur();
      }
    };

    const clampTime = (time) => {
      if (!wavesurfer) return 0;
      const duration = wavesurfer.getDuration() || 0;
      return Math.max(0, Math.min(time, duration));
    };

    const seekToTime = (time) => {
      if (!wavesurfer) return;
      const duration = wavesurfer.getDuration() || 0;
      if (!duration) return;
      const clamped = clampTime(time);
      updatePlayheadUI(clamped);
      previewStartOffset = clamped;
      if (wavesurfer.isPlaying()) {
        wavesurfer.seekTo(clamped / duration);
      }
    };

    const seekBy = (delta) => {
      if (!wavesurfer) return;
      const current = getPlaybackTime();
      seekToTime(current + delta);
    };

    const initWaveform = (blob, label, isAuto) => {
      if (wavesurfer) {
        wavesurfer.destroy();
      }
      if (activeObjectUrl) {
        URL.revokeObjectURL(activeObjectUrl);
      }
      autoMode = isAuto;
      fileLabel.textContent = label || (isAuto ? "auto" : "Loaded file");
      selection = { start: null, end: null };
      activeRegion = null;
      updateSelectionUI();
      zoomLevel = 1;
      zoomBase = 1;
      zoomLevelEl.textContent = "--";
      resetZoomBtn.disabled = true;

      regions = WaveSurfer.Regions.create();
      wavesurfer = WaveSurfer.create({
        container: "#waveform",
        waveColor: "#6b7280",
        progressColor: "#60a5fa",
        cursorColor: "transparent",
        height: 160,
        normalize: true,
        plugins: [regions],
      });

      wavesurfer.on("ready", () => {
        wavesurfer.setVolume(0);
        durationEl.textContent = formatTime(wavesurfer.getDuration());
        currentTimeEl.textContent = formatTime(0);
        const duration = wavesurfer.getDuration() || 1;
        const wrapWidth = waveformWrap.clientWidth || 1;
        zoomBase = Math.max(1, Math.floor(wrapWidth / duration));
        applyZoom(zoomBase);
        updateTimelineScale();
        const message = autoMode
          ? "Ready. Use Space to play, i/o to set selection, d to delete."
          : "Ready. Use Space to play and i/o to set selection.";
        updateStatus(message);
        updatePlayheadUI(0);
        if (pendingSeekTime !== null) {
          seekToTime(pendingSeekTime);
          pendingSeekTime = null;
        }
        if (pendingPlay) {
          wavesurfer.play();
          pendingPlay = false;
        }
      });

      wavesurfer.on("timeupdate", (time) => {
        updatePlayheadUI(time);
      });

      wavesurfer.on("seek", (progress) => {
        const duration = wavesurfer.getDuration() || 0;
        const time = duration * progress;
        updatePlayheadUI(time);
        previewStartOffset = time;
      });

      wavesurfer.on("play", () => {
        startPreviewMix(wavesurfer.getCurrentTime());
      });

      wavesurfer.on("pause", () => {
        stopPreviewMix();
      });

      wavesurfer.on("finish", () => {
        stopPreviewMix();
        updatePlayheadUI(wavesurfer.getDuration());
      });

      regions.enableDragSelection({
        color: "rgba(96, 165, 250, 0.25)",
      });

      regions.on("region-created", (region) => {
        if (activeRegion && activeRegion.id !== region.id) {
          activeRegion.remove();
        }
        activeRegion = region;
        activeRegion.setOptions({ drag: true, resize: true });
        selection = { start: region.start, end: region.end };
        updateSelectionUI();
      });

      regions.on("region-updated", (region) => {
        if (!activeRegion || activeRegion.id !== region.id) return;
        selection = { start: region.start, end: region.end };
        updateSelectionUI();
      });

      regions.on("region-removed", (region) => {
        if (activeRegion && activeRegion.id === region.id) {
          activeRegion = null;
          selection = { start: null, end: null };
          updateSelectionUI();
        }
      });

      activeObjectUrl = URL.createObjectURL(blob);
      console.log("wavesurfer.load", { objectUrl: activeObjectUrl, label, isAuto });
      wavesurfer.load(activeObjectUrl);
    };

    const loadFromUrl = async (url, label, isAuto, seekTime = null, play = false) => {
      try {
        updateStatus("Loading audio...");
        console.log("loadFromUrl fetch", { url, label, isAuto });
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) {
          throw new Error(`Failed to load ${url}`);
        }
        const blob = await res.blob();
        console.log("loadFromUrl blob", { size: blob.size, type: blob.type });
        pendingSeekTime = seekTime;
        pendingPlay = play;
        initWaveform(blob, label, isAuto);
      } catch (err) {
        console.error(err);
        updateStatus(`Load failed: ${err.message}`, true);
      }
    };

    const reloadAuto = async (seekTime, play) => {
      if (!autoMode) {
        updateStatus("Delete/undo requires ?file=auto.", true);
        return;
      }
      const cacheBust = `/api/auto?t=${Date.now()}`;
      console.log("reloadAuto", { cacheBust, seekTime, play });
      stopPreviewMix();
      if (wavesurfer) {
        wavesurfer.pause();
      }
      if (activeObjectUrl) {
        URL.revokeObjectURL(activeObjectUrl);
        activeObjectUrl = null;
      }
      await loadFromUrl(cacheBust, "auto", true, seekTime, play);
    };

    const reloadAutoForced = async (seekTime, play) => {
      autoMode = true;
      await reloadAuto(seekTime, play);
    };

    const deleteSelection = async () => {
      console.log("deleteSelection called", { selection, autoMode, busy });
      if (busy) return;
      if (!selection.start && selection.start !== 0 || selection.end === null) {
        updateStatus("No selection to delete.", true);
        return;
      }
      if (!autoMode) {
        console.log("deleteSelection skipping server delete (non-auto mode)");
        clearSelection();
        updateStatus("Selection cleared (local only).");
        return;
      }
      const start = selection.start;
      const end = selection.end;
      const duration = end - start;
      if (duration <= 0) {
        updateStatus("Invalid selection.", true);
        return;
      }
      console.log("deleteSelection range", { start, end, duration });
      const currentTime = getPlaybackTime();
      const wasPlaying = wavesurfer.isPlaying();
      let targetTime = currentTime;
      if (currentTime > end) {
        targetTime = currentTime - duration;
      } else if (currentTime >= start && currentTime <= end) {
        targetTime = start;
      }
      busy = true;
      wavesurfer.pause();
      updateStatus("Deleting selection...");
      try {
        console.log("deleteSelection sending request", { start, end });
        const res = await fetch("/api/delete", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ start, end }),
        });
        console.log("deleteSelection response", { ok: res.ok, status: res.status });
        if (!res.ok) {
          const text = await res.text();
          console.log("deleteSelection response text", text);
          throw new Error(text || `HTTP ${res.status}`);
        }
        console.log("deleteSelection clearing selection + reload");
        clearSelection();
        await reloadAuto(targetTime, wasPlaying);
        updateStatus("Deleted selection.");
      } catch (err) {
        console.error(err);
        updateStatus(`Delete failed: ${err.message}`, true);
      } finally {
        busy = false;
      }
    };

    const undoDelete = async () => {
      if (busy) return;
      if (!autoMode) {
        updateStatus("Undo only works with ?file=auto.", true);
        return;
      }
      const currentTime = getPlaybackTime();
      const wasPlaying = wavesurfer.isPlaying();
      busy = true;
      wavesurfer.pause();
      updateStatus("Restoring previous audio...");
      try {
        const res = await fetch("/api/undo", { method: "POST" });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || `HTTP ${res.status}`);
        }
        clearSelection();
        await reloadAuto(currentTime, wasPlaying);
        updateStatus("Undo complete.");
      } catch (err) {
        console.error(err);
        updateStatus(`Undo failed: ${err.message}`, true);
      } finally {
        busy = false;
      }
    };

    fileInput.addEventListener("change", (evt) => {
      const file = evt.target.files?.[0];
      if (!file) return;
      fileInput.blur();
      const formData = new FormData();
      formData.append("file", file, file.name);
      updateStatus("Uploading audio...");
      fetch("/api/upload", { method: "POST", body: formData })
        .then((res) => {
          if (!res.ok) {
            return res.text().then((text) => {
              throw new Error(text || `Upload failed (${res.status})`);
            });
          }
          return res.json();
        })
        .then(() => {
          updateStatus("Upload complete.");
          previewStartOffset = 0;
          reloadAutoForced(0, false);
        })
        .catch((err) => {
          console.error(err);
          updateStatus(`Upload failed: ${err.message}`, true);
        });
    });

    resetZoomBtn.addEventListener("click", () => {
      if (!wavesurfer) return;
      resetZoom();
    });

    waveformWrap.addEventListener("wheel", (event) => {
      if (!wavesurfer) return;
      if (!event.ctrlKey) return;
      event.preventDefault();
      const direction = event.deltaY < 0 ? 1 : -1;
      const step = Math.max(5, Math.round(zoomLevel * 0.1));
      const next = Math.max(zoomBase, zoomLevel + direction * step);
      applyZoom(next);
    }, { passive: false });

    waveformWrap.addEventListener("scroll", () => {
      if (syncingScroll) return;
      syncingScroll = true;
      bgmTimelineWrap.scrollLeft = waveformWrap.scrollLeft;
      syncingScroll = false;
    });

    bgmTimelineWrap.addEventListener("scroll", () => {
      if (syncingScroll) return;
      syncingScroll = true;
      waveformWrap.scrollLeft = bgmTimelineWrap.scrollLeft;
      syncingScroll = false;
    });

    bgmTimelineWrap.addEventListener("click", (event) => {
      if (event.detail > 1) return;
      selectBgm(null);
    });

    bgmVolumeEl.addEventListener("input", () => {
      const segment = bgmSegments.find((item) => item.id === selectedBgmId);
      if (!segment) return;
      segment.volume = parseFloat(bgmVolumeEl.value);
      if (previewGain) {
        previewGain.gain.value = segment.volume;
      }
      persistLayout();
    });

    bgmFadeInEl.addEventListener("change", () => {
      const segment = bgmSegments.find((item) => item.id === selectedBgmId);
      if (!segment) return;
      segment.fadeIn = Math.max(0, parseFloat(bgmFadeInEl.value || 0));
      persistLayout();
    });

    bgmFadeOutEl.addEventListener("change", () => {
      const segment = bgmSegments.find((item) => item.id === selectedBgmId);
      if (!segment) return;
      segment.fadeOut = Math.max(0, parseFloat(bgmFadeOutEl.value || 0));
      persistLayout();
    });

    const stopPreviewMix = () => {
      previewSources.forEach((source) => {
        try {
          source.stop(0);
        } catch (err) {
          // ignore
        }
      });
      previewSources = [];
    };

    const loadPreviewBuffers = async () => {
      if (!previewContext) {
        previewContext = new AudioContext();
      }
      if (!previewBgmBuffer && bgmFile) {
        const bgmData = await bgmFile.arrayBuffer();
        previewBgmBuffer = await previewContext.decodeAudioData(bgmData.slice(0));
      }
    };

    const startPreviewMix = async (offsetSeconds = 0) => {
      if (!bgmFile || bgmSegments.length === 0) {
        return;
      }
      await loadPreviewBuffers();
      if (!previewBgmBuffer) {
        return;
      }
      stopPreviewMix();
      if (previewContext && previewContext.state === "suspended") {
        await previewContext.resume();
      }
      previewGain = previewContext.createGain();
      previewGain.gain.value = parseFloat(bgmVolumeEl.value || 0);
      previewGain.connect(previewContext.destination);
      const offset = Math.max(0, offsetSeconds);
      bgmSegments.forEach((segment) => {
        const segDuration = Math.max(0, segment.end - segment.start);
        if (!segDuration) return;
        const bgmSource = previewContext.createBufferSource();
        bgmSource.buffer = previewBgmBuffer;
        bgmSource.connect(previewGain);
        const segStart = segment.start;
        if (segStart + segDuration <= offset) return;
        const relativeStart = Math.max(0, segStart - offset);
        const segOffset = Math.max(0, segment.offset + (offset - segStart > 0 ? offset - segStart : 0));
        const playDuration = Math.max(0, segDuration - (offset - segStart > 0 ? offset - segStart : 0));
        if (playDuration <= 0) return;
        bgmSource.start(previewContext.currentTime + relativeStart, segOffset, playDuration);
        previewSources.push(bgmSource);
      });
    };


    mixBgmBtn.addEventListener("click", async () => {
      if (!autoMode) {
        updateStatus("Mix requires ?file=auto.", true);
        return;
      }
      if (!bgmFile) {
        updateStatus("Load a BGM file first.", true);
        return;
      }
      updateStatus("Mixing BGM...");
      try {
        await ensureBgmUpload();
        const segments = bgmSegments
          .filter((segment) => (segment.end - segment.start) > 0)
          .map((segment) => ({
            ...segment,
            file: segment.file || bgmUploadPath,
            offset: Math.max(0, segment.offset),
            volume: Number(segment.volume) || bgmDefaultVolume,
            fadeIn: Number(segment.fadeIn) || bgmDefaultFade,
            fadeOut: Number(segment.fadeOut) || bgmDefaultFade,
          }));
        if (segments.length === 0) {
          throw new Error("No valid BGM segments to mix.");
        }
        const layout = {
          version: 1,
          segments: segments.map((segment) => ({
            file: segment.file,
            name: segment.name,
            start: segment.start,
            end: segment.end,
            offset: segment.offset,
            volume: segment.volume,
            fade_in: segment.fadeIn,
            fade_out: segment.fadeOut,
          })),
        };
        const res = await fetch("/api/bgm/layout", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(layout),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || `Layout save failed (${res.status})`);
        }
        const mixRes = await fetch("/api/mix", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ output: "mixed.wav" }),
        });
        if (!mixRes.ok) {
          const text = await mixRes.text();
          throw new Error(text || `Mix failed (${mixRes.status})`);
        }
        const output = await mixRes.json();
        const outputName = output.output ? output.output.split("/").pop() : "mixed.wav";
        updateStatus(`Mix complete. Output: ${outputName}`);
      } catch (err) {
        console.error(err);
        updateStatus(`Mix failed: ${err.message}`, true);
      }
    });

    const handleBgmFile = async (file) => {
      updateStatus("Loading BGM...");
      try {
        const duration = await readDuration(file);
        bgmFile = file;
        bgmUploadPath = null;
        bgmDuration = duration;
        previewBgmBuffer = null;
        initBgmWaveform(file);
        addBgmSegment({ name: file.name, duration, file: null });
        updateMixAvailability();
        bgmFileLabel.textContent = `♪ ${file.name}`;
        bgmPanel.classList.add("bgm-loaded");
        updateStatus("BGM loaded.");
      } catch (err) {
        console.error(err);
        updateStatus(`BGM load failed: ${err.message}`, true);
      }
    };

    addBgmBtn.addEventListener("click", () => {
      if (!bgmFile) {
        updateStatus("Load a BGM file first.", true);
        return;
      }
      const duration = bgmDuration || (bgmWaveSurfer ? bgmWaveSurfer.getDuration() || 0 : 0);
      addBgmSegment({ name: bgmFile.name, duration, file: bgmUploadPath });
      updateStatus("BGM block added.");
    });

    bgmInput.addEventListener("change", async (event) => {
      const file = event.target.files?.[0];
      if (!file) return;
      await handleBgmFile(file);
      bgmInput.value = "";
      bgmInput.blur();
      detachHiddenFileInputs();
    });

    bgmTimelineWrap.addEventListener("dragover", (event) => {
      event.preventDefault();
    });

    bgmTimelineWrap.addEventListener("drop", async (event) => {
      event.preventDefault();
      const file = event.dataTransfer?.files?.[0];
      if (!file) return;
      await handleBgmFile(file);
    });

    document.addEventListener("keydown", (event) => {
      if (!wavesurfer) return;
      if (event.target && event.target.tagName === "INPUT" && event.target.type !== "file") return;
      const key = event.key;
      detachHiddenFileInputs();
      const current = wavesurfer.getCurrentTime();
      if (key === " ") {
        event.preventDefault();
        if (wavesurfer.isPlaying()) {
          wavesurfer.pause();
        } else {
          wavesurfer.play();
        }
        return;
      }
      if (key === "i" || key === "I") {
        event.preventDefault();
        setSelectionPoint("start", current);
        return;
      }
      if (key === "o" || key === "O") {
        event.preventDefault();
        setSelectionPoint("end", current);
        return;
      }
      if (key === "d" || key === "D") {
        event.preventDefault();
        if (selection.start !== null && selection.end !== null) {
          deleteSelection();
          return;
        }
        updateStatus("No selection to delete.", true);
        return;
      }
      if (event.metaKey && !event.shiftKey && (key === "z" || key === "Z")) {
        event.preventDefault();
        undoDelete();
        return;
      }
      if (event.metaKey && event.shiftKey && (key === "z" || key === "Z")) {
        event.preventDefault();
        updateStatus("Redo not available yet.", true);
        return;
      }
      if (event.metaKey && key === "ArrowLeft") {
        event.preventDefault();
        seekToTime(0);
        return;
      }
      if (event.metaKey && key === "ArrowRight") {
        event.preventDefault();
        seekToTime(wavesurfer.getDuration());
        return;
      }
      if (key === "ArrowLeft") {
        event.preventDefault();
        seekBy(-1);
        return;
      }
      if (key === "ArrowRight") {
        event.preventDefault();
        seekBy(1);
        return;
      }
      if (key === "Escape") {
        event.preventDefault();
        clearSelection();
        selectBgm(null);
        return;
      }
      if (key === "Delete" || key === "Backspace") {
        event.preventDefault();
        if (selection.start !== null && selection.end !== null) {
          deleteSelection();
        }
      }
    });

    const params = new URLSearchParams(window.location.search);
    const fileParam = params.get("file");
    const isAutoFile = (fileParam || "").toLowerCase() === "auto";
    if (fileParam) {
      const url = isAutoFile ? "/api/auto" : fileParam;
      loadFromUrl(url, fileParam, isAutoFile);
    } else if (isAutoFile) {
      loadFromUrl("/api/auto", "auto", true);
    }
  </script>
</body>
</html>
